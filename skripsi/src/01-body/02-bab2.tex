%-----------------------------------------------------------------------------%
\chapter{\babDua}
%-----------------------------------------------------------------------------%

%-----------------------------------------------------------------------------%
\section{Perangkat Lunak (\f{Software})}
%-----------------------------------------------------------------------------%
Perangkat lunak adalah serangkaian instruksi, data, atau program yang digunakan untuk mengoperasikan komputer dan menjalankan tugas-tugas tertentu \cite{gee23}. Perangkat lunak memberikan instruksi kepada perangkat keras (hardware) tentang apa yang harus dilakukan, bertindak sebagai perantara antara pengguna dan perangkat keras. Tanpa perangkat lunak, sebagian besar hardware komputer tidak akan berfungsi. Sebagai contoh, prosesor membutuhkan instruksi dari perangkat lunak untuk melakukan perhitungan, dan monitor membutuhkan driver perangkat lunak untuk menampilkan gambar. Perangkat lunak tidak memiliki wujud fisik dan bersifat intangible, berbeda dengan hardware yang dapat disentuh. Perangkat lunak didistribusikan dalam berbagai bentuk, seperti program yang diinstal pada komputer, aplikasi mobile, aplikasi web, dan embedded systems.

\subsection{Perangkat Lunak Sistem}
Perangkat lunak sistem merupakan fondasi yang memungkinkan perangkat lunak aplikasi dan pengguna berinteraksi dengan perangkat keras \cite{gee23}. Fungsinya antara lain mengelola sumber daya sistem seperti memori, prosesor, dan perangkat input/output. Perangkat lunak sistem juga menyediakan layanan dasar seperti sistem file, manajemen proses, dan antarmuka pengguna. Contoh perangkat lunak sistem meliputi:

\begin{enumerate}
	\item \bo{Sistem Operasi (\f{Operating System}):} Bertindak sebagai platform untuk menjalankan perangkat lunak aplikasi. Sistem operasi mengelola sumber daya hardware, menyediakan antarmuka pengguna, dan menjalankan layanan sistem. Contoh: Microsoft Windows, macOS, Linux, Android, iOS.

	\item \bo{Driver Perangkat Keras (\f{Device Drivers}):} Program yang memungkinkan sistem operasi untuk berkomunikasi dengan perangkat keras tertentu, seperti printer, kartu grafis, kartu suara, webcam, dan mouse. Setiap perangkat keras membutuhkan driver khusus agar dapat berfungsi dengan baik.

\end{enumerate}

\begin{figure}[!htb]
	\begin{minipage}{0.52\textwidth}
		\centering
		\includegraphics[width=0.8\linewidth]
		{\Assets/windows.png}
	\end{minipage}\hfill
	\begin{minipage}{0.38\textwidth}
		\includegraphics[width=0.4\linewidth]
		{\Assets/linux.png}
	\end{minipage}
	\caption{Sistem Operasi Windows \& Linux}
\end{figure}

\subsection{Perangkat Lunak Aplikasi}
Perangkat lunak aplikasi dirancang untuk memenuhi kebutuhan spesifik pengguna \cite{gee23}. Kategori perangkat lunak aplikasi sangat luas dan beragam, berfokus pada penyelesaian tugas-tugas tertentu untuk pengguna. Perangkat lunak aplikasi berjalan di atas sistem operasi dan memanfaatkan layanan yang disediakan oleh sistem operasi.

\begin{itemize}

	\item \bo{Pengolah Kata (\f{Word Processors}):} Digunakan untuk membuat dan mengedit dokumen teks, memformat teks, menambahkan gambar dan tabel, dan melakukan tugas-tugas pengolah kata lainnya. Contoh: Microsoft Word, Google Docs
	\item \bo{Perangkat Lunak Desain Grafis:} Digunakan untuk membuat dan mengedit gambar, ilustrasi, dan desain visual lainnya. Contoh: Adobe Photoshop, GIMP, Inkscape.

\end{itemize}

\begin{figure}[!htb]
	\begin{minipage}{0.5\textwidth}
		\centering
		\includegraphics[width=0.3\linewidth]
		{\Assets/word.png}
	\end{minipage}
	\begin{minipage}{0.5\textwidth}
		\includegraphics[width=0.3\linewidth]
		{\Assets/photoshop.png}
	\end{minipage}
	\caption{Perangkat lunak aplikasi}
\end{figure}

\subsection{Proses Kompilasi dan Eksekusi Perangkat Lunak}
Proses menjalankan perangkat lunak melibatkan dua tahap utama: kompilasi dan eksekusi. Kedua tahap ini penting untuk mengubah kode sumber yang dapat dibaca manusia menjadi instruksi yang dapat dieksekusi oleh mesin. Berikut penjelasan lebih detail, dibagi menjadi dua sub-bagian:

\subsubsection{Proses Kompilasi}
Proses kompilasi mengubah kode sumber (source code) yang ditulis dalam bahasa pemrograman tingkat tinggi menjadi kode mesin (machine code) atau kode objek (object code) \cite{tut24}. Proses ini melibatkan beberapa tahapan, yang masing-masing dilakukan oleh program utilitas yang berbeda:

\begin{enumerate}
	\item \bo{Preprocessing:} Tahap pertama dalam proses kompilasi adalah preprocessing. Preprocessor menangani direktif-direktif preprocessor yang dimulai dengan simbol \#, seperti \#include dan \#define dalam kode sumber.
	\item \bo{Compilation:} Pada tahap ini, compiler menerjemahkan kode sumber yang telah diproses menjadi assembly code. Assembly code adalah representasi mnemonic dari kode mesin, yang lebih mudah dibaca oleh manusia. Kompiler melakukan analisis sintaks dan semantik untuk memastikan kode sumber valid dan sesuai dengan aturan bahasa pemrograman. Kompiler juga melakukan optimasi kode untuk meningkatkan kinerja program.
	\item \bo{Assembly:} Assembler menerjemahkan assembly code menjadi kode objek (object code). Kode objek adalah representasi biner dari instruksi mesin, tetapi belum siap untuk dieksekusi. Kode objek berisi instruksi mesin dan data, tetapi belum terhubung dengan library eksternal.
	\item \bo{Linking:} Linker menggabungkan kode objek dari berbagai file sumber dan library menjadi satu file executable. Linker menyelesaikan referensi eksternal, mengalokasikan alamat memori untuk variabel dan fungsi, dan menghubungkan kode objek dengan library yang dibutuhkan. Output dari tahap linking adalah file executable yang siap dieksekusi.
\end{enumerate}

\begin{figure}
	\centering
	\includegraphics[width=0.35\textheight]
	{\Assets/program_compile.png}
	\caption{Alur kompilasi program \cite{tut24}}
\end{figure}

\subsubsection{Proses Eksekusi}
Setelah program dikompilasi menjadi file executable, proses eksekusi dimulai \cite{Dan24}. Proses eksekusi melibatkan beberapa tahapan yang dilakukan oleh sistem operasi:
\begin{enumerate}
	\item \bo{Loading:} Loader yaitu sebuah komponen dari sistem operasi, memuat file executable ke dalam memori utama (RAM). Loader mengalokasikan ruang memori yang dibutuhkan oleh program, memuat instruksi dan data ke dalam memori, dan menginisialisasi program untuk eksekusi.
	\item \bo{Eksekusi:} Setelah program dimuat ke dalam memori, prosesor mulai mengeksekusi instruksi-instruksi yang terdapat dalam program. Prosesor mengambil instruksi satu per satu dari memori, mendekode instruksi, dan mengeksekusinya. Siklus ini berulang hingga program selesai dijalankan atau dihentikan.
	\item \bo{Terminasi:} Program berakhir ketika mencapai instruksi terminasi atau ketika terjadi kesalahan yang menyebabkan program berhenti secara paksa. Sistem operasi kemudian membebaskan sumber daya yang digunakan oleh program, seperti memori dan file.
\end{enumerate}

\begin{figure}
	\centering
	\includegraphics[height=0.4\textheight]
	{\Assets/program_execution.png}
	\caption{Alur eksekusi program \cite{Dan24}}
\end{figure}


\section{\f{Software Control Flow}}
Alur kendali perangkat lunak (software control flow) merupakan aspek fundamental dalam eksekusi program, merepresentasikan urutan instruksi yang dieksekusi oleh prosesor untuk mencapai tujuan fungsionalitas program \cite{cod23}. Memahami software control flow adalah krusial dalam analisis kode, terutama dalam reverse engineering karena memungkinkan pemetaan jalur eksekusi, identifikasi bottleneck, dan potensi kerentanan. Dalam konteks ini, control flow bukan hanya sekadar urutan instruksi, tetapi juga representasi logis dari bagaimana program merespons input, kondisi, dan interaksi dengan sistem operasi. Pemahaman yang komprehensif terhadap aspek ini memberikan dasar yang kuat dalam menganalisis perilaku program, baik secara statis melalui analisis kode sumber dan intermediate representation, maupun secara dinamis melalui observasi eksekusi runtime.

\subsection{\f{Control Flow Instructions}}
Instruksi alur kendali (control flow instructions) adalah mekanisme fundamental yang menentukan urutan eksekusi instruksi dalam suatu program \cite{cod23}. Instruksi ini memungkinkan program untuk membuat keputusan, mengulang blok kode, dan melompat ke bagian kode yang berbeda. Cara instruksi-instruksi ini direpresentasikan dan diimplementasikan sangat bergantung pada tingkat bahasa pemrograman yang digunakan. Secara umum, kita membedakan antara bahasa tingkat tinggi dan bahasa tingkat rendah.

\subsubsection{\f{High Level Languages}}
Bahasa pemrograman tingkat tinggi (high-level languages), seperti Python, Java, C++, dan JavaScript, menyediakan abstraksi yang jauh dari detail hardware. Bahasa-bahasa ini fokus pada kemudahan penulisan dan pemahaman kode oleh programmer, dengan menggunakan sintaks yang lebih dekat dengan bahasa manusia. Instruksi control flow dalam bahasa tingkat tinggi diimplementasikan melalui konstruksi yang intuitif, seperti \textit{if, else, for}, dan \textit{while}.

\paragraph{Conditional Instructions:}
\begin{itemize}
	\item \bi{if statement:} Memungkinkan program membuat keputusan berdasarkan kondisi, seperti pada contoh di Kode \ref{lst:if_example_cpp}.
	      \begin{minted}{cpp}     
if (x > 10) {
 std::cout << "x lebih besar dari 10" << std::endl;
}
    \end{minted}
    \captionof{listing}{Contoh Penggunaan Pernyataan \code{if} dalam C++}
    \label{lst:if_example_cpp}

	\item \bi{if-else statement:} Menyediakan jalur alternatif jika kondisi \textit{if} tidak terpenuhi, sebagaimana diilustrasikan pada Kode \ref{lst:ifelse_example_cpp}.
	      \begin{minted}{cpp}     
if (score >= 70) {
 std::cout << "Lulus" << std::endl;
} else {
 std::cout << "Tidak Lulus" << std::endl;
}
    \end{minted}
    \captionof{listing}{Contoh Penggunaan Pernyataan \code{if-else} dalam C++}
    \label{lst:ifelse_example_cpp}

	\item \bi{switch statement:} Memungkinkan percabangan ke banyak kasus (lihat Kode \ref{lst:switch_example_cpp}).
	      \begin{minted}{cpp}     
int day = 2;
switch (day) {
 case 1:
 std::cout << "Senin" << std::endl;
 break;
 case 2:
 std::cout << "Selasa" << std::endl;
 break;
 default:
 std::cout << "Hari lain" << std::endl;
}
    \end{minted}
    \captionof{listing}{Contoh Penggunaan Pernyataan \code{switch} dalam C++}
    \label{lst:switch_example_cpp}
\end{itemize}

\paragraph{Loop Instructions:}
\begin{itemize}
	\item \bi{for loop:} Mengeksekusi blok kode sejumlah kali tertentu, seperti tampak pada Kode \ref{lst:for_example_cpp}.
	      \begin{minted}{cpp}     
for (int i = 0; i < 5; i++) {
 std::cout << i << std::endl;
}
    \end{minted}
    \captionof{listing}{Contoh Penggunaan Perulangan \code{for} dalam C++}
    \label{lst:for_example_cpp}

	\item \bi{while loop:} Mengeksekusi blok kode selama kondisi tertentu terpenuhi (Kode \ref{lst:while_example_cpp}).
	      \begin{minted}{cpp}     
int count = 0;
while (count < 5) {
 std::cout << count << std::endl;
 count++;
}
    \end{minted}
    \captionof{listing}{Contoh Penggunaan Perulangan \code{while} dalam C++}
    \label{lst:while_example_cpp}
\end{itemize}

\paragraph{Jump Instructions (Indirect - Function Calls):}
\begin{itemize}
	\item \bi{Function call:} Memindahkan kontrol ke fungsi lain dan kembali setelah selesai, seperti pada contoh pemanggilan \code{myFunction} di Kode \ref{lst:function_call_example_cpp}.
	      \begin{minted}{cpp}
void myFunction() {
 std::cout << "Hello" << std::endl;
}
int main() {
 myFunction();
 return 0;
}
    \end{minted}
    \captionof{listing}{Contoh Pemanggilan Fungsi dalam C++}
    \label{lst:function_call_example_cpp}
\end{itemize}

\subsubsection{\f{Low Level Languages}}
Bahasa pemrograman tingkat rendah (low-level languages), seperti Assembly language, bekerja lebih dekat dengan hardware. Instruksi-instruksinya langsung dikodekan ke dalam instruksi mesin yang dapat dieksekusi oleh prosesor. Bahasa tingkat rendah memberikan kontrol yang lebih besar atas hardware, tetapi seringkali lebih kompleks dan sulit untuk dipahami oleh manusia. Instruksi control flow pada tingkat ini melibatkan kode operasi (opcode) yang merepresentasikan operasi jump dan perbandingan secara langsung \cite{USC24}. Dalam bagian ini, contoh akan difokuskan pada bahasa x86 Assembly.

\paragraph{Conditional Instructions:}
\begin{itemize}
	\item \bi{cmp (compare):} Membandingkan dua nilai dan mengatur flags (bendera) kondisi (Kode \ref{lst:cmp_example_asm}).
	      \begin{minted}{asm}     
cmp eax, 10
    \end{minted}
    \captionof{listing}{Contoh Instruksi Perbandingan \code{cmp} dalam Assembly x86}
    \label{lst:cmp_example_asm}

	\item \bi{jle, jge, je, jne (conditional jumps):} Melompat ke label lain jika flags kondisi memenuhi syarat, seperti yang ditunjukkan pada Kode \ref{lst:cond_jump_example_asm}.
	      \begin{minted}{asm}     
jle less_or_equal ; Lompat jika kurang dari atau sama dengan
jne not_equal ; Lompat jika tidak sama dengan
    \end{minted}
    \captionof{listing}{Contoh Instruksi Lompatan Kondisional dalam Assembly x86}
    \label{lst:cond_jump_example_asm}
\end{itemize}

\paragraph{Loop Instructions (Implementasi dengan Conditional Jumps):}
\begin{itemize}
	\item Menggunakan kombinasi instruksi perbandingan, pengurangan counter, dan conditional jump untuk membuat loop (lihat contoh pada Kode \ref{lst:loop_example_asm}).
	      \begin{minted}{asm}     
mov ecx, 5 ; set counter loop
loop_start:
; instruksi dalam loop
cmp ecx, 0
jne loop_start
    \end{minted}
    \captionof{listing}{Contoh Implementasi Perulangan Sederhana dalam Assembly x86}
    \label{lst:loop_example_asm}
\end{itemize}

\paragraph{Jump Instructions (Direct):}
\begin{itemize}
	\item \bi{jmp (unconditional jump):} Lompat ke label tanpa syarat (Kode \ref{lst:jmp_example_asm}).
	      \begin{minted}{asm}     
jmp target_label
    \end{minted}
    \captionof{listing}{Contoh Instruksi Lompatan Tanpa Syarat \code{jmp} dalam Assembly x86}
    \label{lst:jmp_example_asm}
\end{itemize}

\paragraph{Jump Instructions (Indirect - function calls):}
\begin{itemize}
	\item \bi{call:} Melompat ke alamat fungsi dan menyimpan alamat return (Kode \ref{lst:call_example_asm}).
	      \begin{minted}{asm}     
call function_address
    \end{minted}
    \captionof{listing}{Contoh Instruksi Pemanggilan Fungsi \code{call} dalam Assembly x86}
    \label{lst:call_example_asm}

	\item \bi{ret:} Mengembalikan kontrol dari fungsi (Kode \ref{lst:ret_example_asm}).
	      \begin{minted}{asm}     
ret
    \end{minted}
    \captionof{listing}{Contoh Instruksi Pengembalian Fungsi \code{ret} dalam Assembly x86}
    \label{lst:ret_example_asm}
\end{itemize}

%-----------------------------------------------------------------------------%
\section{Rekayasa balik (\f{Reverse Engineering})}
%-----------------------------------------------------------------------------%
Rekayasa balik (reverse engineering) adalah proses menganalisis suatu sistem, baik perangkat lunak, perangkat keras, atau sistem lainnya, untuk mengidentifikasi komponen-komponennya dan interaksi antar komponen, serta memahami cara kerja sistem tersebut tanpa akses ke kode sumber \cite{gee24}.  Tujuannya beragam, mulai dari pemahaman fungsionalitas, analisis keamanan untuk menemukan kerentanan, pemulihan desain, hingga modifikasi dan peningkatan sistem. Rekayasa balik dapat diterapkan pada berbagai skenario, misalnya untuk menganalisis malware, memahami format file yang tidak terdokumentasi, mempelajari teknik yang digunakan oleh pesaing atau modifikasi fungsionalitas perangkat lunak.

\subsection{Jenis Analisis Rekayasa Balik}
\begin{enumerate}
	\item \bo{Analisis Statis}\\
	      Analisis statis melibatkan pemeriksaan kode tanpa menjalankannya. Analisis statis berfokus pada struktur dan logika kode, mencari pola dan kerentanan \cite{Sec19}. Alat yang digunakan dalam analisis statis meliputi:
	      \begin{itemize}
		      \item \bi{Disassembler:}  Menerjemahkan kode mesin menjadi assembly code, sebuah representasi kode yang lebih mudah dibaca oleh manusia. Contoh: IDA Pro, Ghidra, Radare2.
		      \item \bi{Decompiler:}  Menerjemahkan kode mesin atau bytecode kembali ke kode sumber tingkat tinggi (misalnya, C++ atau Java). Decompiler membantu memahami logika program secara lebih mudah.
		      \item \bi{Code Analysis Tools:}  Alat yang digunakan untuk menganalisis kode secara otomatis, mencari kerentanan keamanan, pola kode yang buruk, dan masalah lainnya.
	      \end{itemize}

	      \begin{figure}
		      \centering
		      \includegraphics[width=.75\textwidth]
		      {\Assets/program_decompile.png}
		      \caption{Dekompilasi Aplikasi \cite{Ore06}}
	      \end{figure}
	\item \bo{Analisis Dinamik} \\
	      Analisis dinamis melibatkan menjalankan program dan mengamati perilakunya. Analisis dinamis berfokus pada bagaimana program berinteraksi dengan lingkungannya, mencari kerentanan runtime dan memahami alur eksekusi \cite{Sec19}.  Alat yang digunakan dalam analisis dinamis meliputi:
	      \begin{itemize}
		      \item \bi{Debugger:} Memungkinkan eksekusi program secara terkontrol, memeriksa nilai variabel, dan melacak alur eksekusi. Contoh: x64dbg, OllyDbg, GDB.
		      \item \bi{Profiler:} Mengukur penggunaan sumber daya program, seperti waktu eksekusi, penggunaan memori, dan akses file. Profiler membantu mengidentifikasi bottleneck kinerja.
	      \end{itemize}
\end{enumerate}

\subsection{\f{Tampering}}
\f{Tampering} merupakan suatu proses mengubah kode aplikasi untuk mempengaruhi perilakunya. Contoh Tampering perangkat lunak adalah mengubah kode aplikasi agar dapat melewati proses autentikasi dalam perangkat lunak tersebut. Hal ini dapat dilakukan dengan memodifikasi control flow pada proses autentikasi dalam programnya. \\
\f{Tampering} bisa dilakukan pada berbagai tingkatan dan bagian dari perangkat lunak, termasuk
\begin{itemize}
	\item \bo{Kode biner (\textit{executable code}):} Mengubah instruksi mesin yang dijalankan oleh prosesor. Hal ini bisa digunakan untuk mematikan fitur tertentu, menambahkan fitur baru, mengubah perilaku program, atau menyisipkan kode berbahaya.
	\item \bo{Data} Mengubah data konfigurasi, aset game, atau data sensitif lainnya yang digunakan oleh program.
	\item \bo{Pustaka (\textit{Library}):} Memodifikasi library yang digunakan oleh program untuk mengubah fungsionalitasnya.
	\item \bo{Sumber Daya (\textit{Resources}):} Mengubah teks, gambar, atau elemen lain yang digunakan oleh program.
\end{itemize}


\subsection{Alat-alat untuk Rekayasa Balik}
\begin{itemize}
	\item \bo{IDA Pro (Interactive Disassembler Pro):} Disassembler dan debugger komersial yang sangat populer dan powerful. IDA Pro mendukung berbagai arsitektur prosesor dan sistem operasi, menyediakan antarmuka yang canggih untuk analisis kode, dan mendukung plugin untuk ekstensibilitas \cite{Hex91}.
	      \begin{figure}
		      \centering
		      \includegraphics[width=.5\textwidth]
		      {\Assets/IDA_pro.png}
		      \caption{IDA Pro \cite{Hex91}}
	      \end{figure}
	\item \bo{Ghidra:} Framework reverse engineering open-source yang dikembangkan oleh NSA (National Security Agency). Ghidra menawarkan fitur yang setara dengan IDA Pro, termasuk disassembler, decompiler, dan debugger. Ghidra juga mendukung scripting dan ekstensibilitas melalui plugin \cite{Nat19}.
	      \begin{figure}
		      \centering
		      \includegraphics[width=.3\textwidth]
		      {\Assets/Ghidra.png}
		      \caption{Ghidra \cite{Nat19}}
	      \end{figure}
	\item \bo{x64dbg:} Debugger open-source untuk platform Windows. x64dbg menyediakan antarmuka yang modern dan user-friendly, serta mendukung plugin dan scripting. x64dbg fokus pada analisis malware dan reverse engineering aplikasi Windows \cite{Dun14}.
	      \begin{figure}
		      \centering
		      \includegraphics[width=.4\textwidth]
		      {\Assets/x64Dbg.png}
		      \caption{x64dbg \cite{Dun14}}
	      \end{figure}
\end{itemize}

\subsection{Disassembler: Statis dan Dinamis}

Disassembler adalah alat fundamental dalam rekayasa balik yang berfungsi untuk menerjemahkan kode mesin (urutan byte yang dieksekusi langsung oleh prosesor) kembali ke dalam bentuk bahasa assembly yang dapat dibaca manusia \cite{Sikorski2012}. Bahasa assembly adalah representasi simbolik tingkat rendah dari instruksi mesin, yang memberikan pandangan mendetail tentang operasi yang dilakukan oleh perangkat lunak. Pemahaman terhadap kode assembly hasil disassembly sangat krusial untuk menganalisis logika program, menemukan kerentanan, atau memahami bagaimana program berinteraksi dengan sistem. Terdapat dua pendekatan utama dalam disassembly: statis dan dinamis.

\label{subsec:disassembler_statis}
\subsubsection{Disassembler Statis}

Disassembler statis bekerja dengan menganalisis berkas executable (atau library) secara langsung di disk, tanpa perlu menjalankan program tersebut \cite{Eilam2011}. Alat ini membaca urutan byte dari berkas dan mencoba untuk memetakannya ke instruksi-instruksi assembly yang sesuai dengan arsitektur target (misalnya, x86, x86-64, ARM).

\paragraph{Cara Kerja Disassembler Statis:}
Proses disassembly statis umumnya melibatkan beberapa teknik, di antaranya:

\begin{itemize}
\item \textbf{Linear Sweep Disassembly (Pembongkaran Sapuan Linier):} Ini adalah pendekatan paling sederhana. Disassembler memulai dari alamat awal segmen kode (atau titik masuk yang diketahui) dan secara berurutan menerjemahkan byte demi byte menjadi instruksi assembly \cite{Sikorski2012}. Pendekatan ini cepat tetapi memiliki kelemahan signifikan: ia tidak dapat dengan mudah membedakan antara kode dan data yang mungkin disisipkan di antara instruksi. Jika ada byte data yang secara keliru diinterpretasikan sebagai instruksi, sisa dari proses disassembly bisa menjadi tidak sinkron dan menghasilkan output yang salah.
\item \textbf{Recursive Traversal Disassembly (Pembongkaran Penelusuran Rekursif):} Pendekatan ini lebih canggih dan akurat. Dimulai dari titik masuk yang diketahui, disassembler menelusuri alur kontrol program. Ketika instruksi percabangan (seperti \texttt{JMP}, \texttt{CALL}, atau \texttt{JNZ}) ditemui, disassembler akan mengikuti target dari percabangan tersebut dan melanjutkan proses disassembly dari sana \cite{Eilam2011, Ko2007}. Teknik ini lebih baik dalam membedakan antara kode dan data karena hanya bagian yang dapat dijangkau melalui alur kontrol yang dianggap sebagai kode. Namun, ia dapat menghadapi kesulitan dengan percabangan tidak langsung (indirect jumps/calls) yang targetnya ditentukan saat runtime, atau teknik anti-disassembly yang sengaja mengacaukan alur kontrol.
\end{itemize}

Disassembler statis seperti Ghidra \cite{Nat19} dan IDA Pro \cite{Hex91} menggunakan kombinasi teknik ini, ditambah dengan analisis heuristik dan pemahaman struktur format berkas (seperti PE untuk Windows atau ELF untuk Linux) untuk mengidentifikasi segmen kode, data, tabel impor/ekspor, dan simbol-simbol debug (jika ada).

\paragraph{Keuntungan Disassembler Statis:}
\begin{itemize}
\item \textbf{Analisis Komprehensif:} Dapat menganalisis seluruh program (atau bagian besar darinya) tanpa perlu mengeksekusinya, memberikan gambaran umum struktur dan logika.
\item \textbf{Keamanan:} Tidak ada risiko menjalankan kode berbahaya karena program tidak dieksekusi.
\item \textbf{Reproduktifitas:} Hasil analisis konsisten karena didasarkan pada berkas yang tidak berubah.
\end{itemize}

\paragraph{Keterbatasan Disassembler Statis:}
\begin{itemize}
\item \textbf{Kode yang Dikemas (Packed) atau Dienkripsi:} Jika kode program dikemas (dikompresi dan mungkin dienkripsi) atau dilindungi oleh lapisan enkripsi, disassembler statis hanya akan melihat kode pembuka/dekriptornya, bukan kode asli program sampai kode tersebut didekripsi/dibuka saat runtime \cite{Sikorski2012}.
\item \textbf{Kode yang Memodifikasi Diri Sendiri (Self-Modifying Code):} Disassembler statis tidak dapat secara akurat merepresentasikan kode yang mengubah instruksinya sendiri saat runtime.
\item \textbf{Polimorfisme dan Metamorfisme:} Teknik yang digunakan malware untuk mengubah penampilan kode mereka di setiap infeksi atau eksekusi sangat menyulitkan analisis statis.
\item \textbf{Percabangan Tidak Langsung dan Opaque Predicates:} Sulit untuk menentukan semua kemungkinan jalur eksekusi secara statis jika target lompatan atau kondisi percabangan sangat bergantung pada nilai runtime atau sengaja dibuat ambigu \cite{Eilam2011}.
\item \textbf{Kegagalan pada Kode Tervirtualisasi:} Ini adalah poin krusial terkait VxLang. Ketika kode asli telah ditransformasi menjadi bytecode untuk sebuah Instruction Set Architecture (ISA) kustom yang dijalankan oleh Virtual Machine (VM) internal, disassembler statis seperti Ghidra akan gagal. Ghidra dirancang untuk memahami ISA standar (seperti x86-64). Ia akan mencoba menginterpretasikan bytecode kustom dari VxLang sebagai instruksi x86-64, yang tentu saja tidak valid. Akibatnya, Ghidra akan menampilkan urutan byte yang tidak dikenali (sering direpresentasikan sebagai '???' atau instruksi yang salah) dan tidak mampu merekonstruksi alur logika asli program yang telah divirtualisasi. Proses virtualisasi oleh VxLang secara efektif menyembunyikan kode asli dari analisis statis konvensional.
\end{itemize}

\label{subsec:disassembler_dinamis}
\subsubsection{Disassembler Dinamis (Debugger)}

Disassembler dinamis, atau lebih tepatnya disassembly yang dilakukan secara dinamis, biasanya merupakan fitur integral dari sebuah debugger seperti x64dbg \cite{Dun14}. Proses disassembly ini terjadi saat program sedang berjalan (atau dijeda) di bawah kontrol debugger.

\paragraph{Cara Kerja Disassembler Dinamis:}
Ketika program dieksekusi di dalam debugger, debugger memiliki akses penuh ke ruang memori proses tersebut.
\begin{itemize}
\item \textbf{Pembongkaran Instruksi Saat Ini:} Debugger membaca byte-byte memori pada alamat yang ditunjuk oleh Instruction Pointer (misalnya, register RIP pada arsitektur x86-64) dan menerjemahkannya menjadi instruksi assembly yang akan dieksekusi berikutnya \cite{Sikorski2012}. Ini dilakukan secara on-the-fly.
\item \textbf{Penanganan Kode yang Di-unpack atau Didekripsi:} Jika program menggunakan packer atau enkripsi, disassembler dinamis akan melihat kode asli setelah packer tersebut selesai mengekstrak dan mendekripsi kode ke dalam memori.
\item \textbf{Observasi Perubahan Kode:} Jika program menggunakan self-modifying code, disassembler dinamis (yang dipanggil berulang kali saat stepping) akan menampilkan instruksi yang benar-benar dieksekusi pada setiap langkah, bahkan jika instruksi tersebut baru saja dimodifikasi.
\end{itemize}

\paragraph{Keuntungan Disassembler Dinamis:}
\begin{itemize}
\item \textbf{Mengatasi Kode Terproteksi (Packed/Encrypted):} Sangat efektif untuk menganalisis kode yang baru muncul di memori setelah proses unpacking atau dekripsi runtime.
\item \textbf{Menangani Self-Modifying Code:} Dapat melihat bentuk kode yang sebenarnya dieksekusi.
\item \textbf{Analisis Berdasarkan Eksekusi Nyata:} Hanya menganalisis kode yang benar-benar dijalankan, yang bisa lebih fokus.
\item \textbf{Visibilitas Simbol Runtime:} Debugger dinamis, seperti x64dbg, beroperasi pada proses yang sedang berjalan dan memiliki akses ke informasi simbol yang dimuat oleh sistem operasi. Ini mencakup simbol dari Dynamic Link Libraries (DLL) sistem (misalnya, fungsi API Windows dari \texttt{kernel32.dll}) yang diselesaikan oleh OS loader saat runtime. Jika tersedia, berkas simbol debug (seperti PDB untuk Windows) juga dapat dimuat oleh debugger untuk menampilkan simbol-simbol internal aplikasi.
\end{itemize}

\paragraph{Keterbatasan Disassembler Dinamis:}
\begin{itemize}
\item \textbf{Cakupan Terbatas:} Hanya bagian kode yang dieksekusi selama sesi debug yang dapat dianalisis. Mungkin ada bagian kode yang tidak pernah terjangkau.
\item \textbf{Memakan Waktu:} Memerlukan interaksi manual untuk menelusuri kode, bisa lambat untuk program besar.
\item \textbf{Teknik Anti-Debugging:} Program dapat menggunakan teknik untuk mendeteksi keberadaan debugger dan mengubah perilakunya atau menghentikan eksekusi \cite{Sikorski2012}.
\item \textbf{Analisis Kode Tervirtualisasi oleh VxLang:} Meskipun x64dbg dapat melakukan disassembly terhadap instruksi-instruksi dari *interpreter* atau \textit{Virtual Machine} (VM) milik VxLang itu sendiri (karena VM tersebut adalah kode native), ia tidak akan secara langsung menampilkan kode asli Anda yang telah ditransformasi menjadi bytecode. Yang terlihat adalah kode dari VM yang sedang mengeksekusi bytecode tersebut. Jadi, meskipun x64dbg dapat melihat instruksi yang berjalan, instruksi tersebut bukanlah logika asli program dalam bentuk assembly aslinya, melainkan instruksi-instruksi dari lapisan virtualisasi VxLang. Ini tetap menyulitkan pemahaman logika asli secara langsung.
\end{itemize}

Secara ringkas, disassembler statis memberikan gambaran global namun rentan terhadap teknik obfuscation canggih seperti virtualisasi kode. Di sisi lain, disassembler dinamis (dalam debugger) dapat mengatasi beberapa bentuk proteksi runtime dan melihat simbol yang dimuat oleh OS, tetapi untuk kode yang divirtualisasi seperti oleh VxLang, ia akan menampilkan kode dari VM protektor, bukan kode asli yang telah diubah menjadi bytecode. Kegagalan Ghidra pada aplikasi yang divirtualisasi VxLang adalah karena Ghidra mengharapkan instruksi mesin standar, bukan bytecode dari ISA kustom yang hanya dipahami oleh VM VxLang.

%-----------------------------------------------------------------------------%
\section{\f{Obfuscation}}
%-----------------------------------------------------------------------------%
Obfuscation adalah teknik yang digunakan untuk mengubah kode sumber atau kode mesin menjadi bentuk yang lebih sulit dipahami oleh manusia, tanpa mengubah fungsionalitas program. Tujuan utama obfuscation adalah untuk mempersulit analisis dan reverse engineering, melindungi kekayaan intelektual, dan meningkatkan keamanan aplikasi. Obfuscation tidak membuat kode menjadi tidak mungkin untuk di-reverse engineer, tetapi meningkatkan waktu dan usaha yang dibutuhkan untuk melakukannya, sehingga membuat reverse engineering menjadi kurang menarik bagi penyerang \cite{Jin24}.

\subsection{Manfaat \f{Obfuscation}}
\begin{itemize}
	\item \bo{Meningkatkan Keamanan:} Obfuscation mempersulit penyerang untuk memahami logika program, menemukan kerentanan, dan memodifikasi kode untuk tujuan jahat. Obfuscation dapat melindungi algoritma penting, kunci enkripsi, dan data sensitif lainnya.
	\item \bo{Melindungi Kekayaan Intelektual:} Obfuscation dapat mempersulit pesaing untuk mencuri kode sumber, meniru fungsionalitas program, dan melanggar hak cipta. Ini penting terutama untuk perangkat lunak komersial dan aplikasi yang mengandung algoritma atau teknologi yang unik.
\end{itemize}

\subsection{Jenis-jenis \f{Obfuscation}}
Obfuscation dapat dilakukan pada diterapkan pada kode sumber, bytecode, atau kode biner.
\subsubsection{Kode Sumber \f{Obfuscation}}
Teknik ini mengubah kode sumber yang dapat dibaca manusia, sehingga sulit dipahami tanpa memengaruhi fungsinya \cite{Jin24}.
\begin{itemize}
	\item \bi{Layout obfuscation:} mengubah tampilan kode.
	      \begin{itemize}
		      \item \bi{Scrabling identifiers \cite{Cha04}:} mengubah nama fungsi dan variabel.
		      \item \bi{Changing formatting \cite{Bal11}:} menambahkan atau menghapus spasi putih dan baris baru.
		      \item \bi{Removing comments \cite{Bal11}:} menghapus komentar penjelasan.
	      \end{itemize}
	\item \bi{Data obfuscation:} menyembunyikan cara data disimpan dan diproses.
	      \begin{itemize}
		      \item \bi{Data encocding \cite{Ert05}:} Mengubah representasi data, misalnya mengenkripsi string atau mengubah nilai numerik dengan operasi matematika. Ini membuat data asli sulit dikenali langsung.
		      \item \bi{Instruction Substitution \cite{Dar10}} Mengganti instruksi yang sederhana dengan instruksi yang lebih kompleks atau setara, tetapi lebih sulit dipahami.
		      \item \bi{Mixed boolean arithmetic \cite{Liu21,Sch22}} Menggunakan operasi boolean (AND, OR, XOR, NOT) yang dikombinasikan dengan operasi aritmatika untuk membuat logika program lebih kompleks dan sulit diurai.
	      \end{itemize}
	\item \bi{Control flow obfuscation:} mempersulit logika program.
	      \begin{itemize}
		      \item \bi{Bogus control flow \cite{LiY211}:} menambahkan kode palsu yang memengaruhi alur kontrol.
		      \item \bi{Opaque predicates \cite{XuD16}:} menyisipkan kode sampah ke dalam pernyataan kondisional.
		      \item \bi{Control Flow flattening \cite{LÃ¡s09}:} mengubah struktur program menjadi pernyataan switch yang kompleks.
	      \end{itemize}
\end{itemize}

\subsubsection{\f{Bytecode Obfuscation}}
Bytecode Obfuscation beroperasi pada kode perantara yang dihasilkan setelah kompilasi kode sumber. Hal ini khususnya relevan untuk bahasa seperti Java, .NET, LLVM dimana kode dikompilasi menjadi bytecode dan kemudian dijalankan pada mesin virtual \cite{Pie18} \cite{Yak20}. Tujuannya adalah untuk mempersulit rekayasa balik bytecode menjadi kode sumber dengan mudah.\\
Berikut Teknik-teknik obfuscation pada bytecode :
\begin{itemize}
	\item \bi{Renaming \cite{Pie18} :} Mengubah nama kelas, metode, dan variabel dalam bytecode untuk membuat kode sumber yang didekompilasi lebih sulit dibaca. Misalnya, metode bernama calculateSalary dapat diubah namanya menjadi method1
	\item \bi{Control Flow Obfucsation \cite{Pie18} :} Meggunakna  percabangan yang kompleks, kondisional, dan konstruksi berulang untuk membuat kode yang didekompilasi menjadi non-deterministik dan lebih sulit untuk diikuti
	\item \bi{String Encryption \cite{Pie18} :} Mengenkripsi string yang tertanam dalam bytecode, yang hanya didekripsi saat dijalankan saat dibutuhkan. Hal ini mempersulit pencarian informasi atau data sensitif dengan menganalisis bytecode.
	\item \bi{Dummy Code Insertion \cite{Pie18} :} Menambahkan kode yang tidak memengaruhi logika program, tetapi mempersulit dekompilasi dan analisis
\end{itemize}

\subsubsection{\f{Kode Biner Obfuscation}}
Kode Biner Obfuscation diterapkan pada kode akhir yang dapat dieksekusi mesin. Ini berfokus pada upaya membuat biner sulit dianalisis, dibongkar, dan dipahami. Berikut beberapa teknik yang digunakna untuk obfuscation pada kode biner :
\begin{itemize}
	\item \bi{Code Packing \cite{Rou13} :} kode asli yang dapat dieksekusi dikompresi atau dienkripsi menjadi biner yang dikemas, yang juga menyertakan kode bootstrap yang membongkar kode asli ke dalam memori saat runtime, sehingga melindungi kode asli dari analisis statis.
	\item \bi{Obfuscated Control Flow \cite{Rou13} :} Menggunakan inderect calls dan  jumps, dan memanipulasi instruksi panggilan dan ret untuk mempersulit mengikuti jalur eksekusi program.
	\item \bi{Chunked Control Flow \cite{Rou13} :} Membagi kode menjadi blok-blok yang sangat kecil dengan instruksi lompatan antar blok untuk mengganggu pembongkaran linear assembly.
	\item \bi{Obfuscated Constants \cite{Rou13} :} Menyembunyikan nilai konstan yang digunakan dalam kode melalui berbagai operasi aritmatika atau logika.
	\item \bi{Code Virtualization \cite{Ore06} :} Menerjemahkan kode mesin menjadi instruksi virtual yang dieksekusi oleh mesin virtual khusus yang tertanam dalam aplikasi.
\end{itemize}

\begin{figure}
	\centering
	\includegraphics[width=.8\textwidth]
	{\Assets/code_virtualization_process.png}
	\caption{Prosess Code Virtualization \cite{Ore06}}
	\label{F:virtualization_process}
\end{figure}
%-----------------------------------------------------------------------------%
\section{\f{Code Virtualization}}
%-----------------------------------------------------------------------------%

Code Virtualization atau juga disebut dengan VM-Based Code Obfuscation menerupakan suatu teknik obfuscation dimana kita menerjemahkan kode biner orignal menjadi bytecode baru berdasarkan Instruction Set Architecture (ISA) khusus (Gambar \ref{F:virtualization_process}). Bytecode ini dapat dijalankan secara run-time dengan mesin virtual (i.e. intrepreter) yang tertanam pada aplikasinya \cite{Ore06,Zho24}. Teknik Code virtualization tidak akan mengembalikan sumber kode aslinya dalam memori sedangkan teknik Code Encryption tetap mengembalikan kodenya aslinya dalam memori saat dilakukan dekripsinya \cite{Don20}.

Set instruksi virtual ini merupakan kunci dari obfuscationnya yang digunakan untuk mapping relasi antara intruksi lokal dan instruksi virtual \cite{Zho24} . Intruksi virtual ini membuat aliran kontrol dari original program untuk tidak dapat dibaca dan mempersulit reverse-engineer program. Code Virtualization dapat menghasilkan berbagai mesin virtual dengan set instruksi virtual masing-masing. Dengan ini, setiap copy dari program dapat memiliki instruksi virtual khusus agar mencegah penyerang untuk mengenali opcode mesin virtual menggunakan metode Frequency Analysis \cite{Ore06,Zho24}.

\begin{figure}
	\centering
	\includegraphics[width=0.7\textwidth]
	{\Assets/multiple_virtualization.jpg}
	\caption{Transformasi ISA x86 menjadi berbagai messin virtual \cite{Ore06}}
\end{figure}

Arsitektur umum mesin virtual untuk Code Virtualization memiliki komponen-komponen yang mirip dengan design CPU \cite{Sal18, Hac24}.
\begin{enumerate}
	\item \bi{VM entry:} Perannya untuk simpan konteks eksekusi native (seperti register CPU atau flag) dan transisi ke konteks mesin virtual.
	\item \bi{Fetch:} Perannya adalah untuk mengambil, dari memori internal VM, opcode (virtual) yang akan ditiru, berdasarkan nilai Virtual Program Counter (vpc).
	\item \bi{Decode:} Perannya adalah untuk mendekode opcode yang diambil dan operan yang sesuai untuk menentukan instruksi ISA mana yang akan dieksekusi.
	\item \bi{Dispatch:} Setelah instruksi didekodekan, operator menentukan pengendali mana yang harus dijalankan dan mengatur konteksnya.
	\item \bi{Handlers:} Meniru instruksi virtual melalui rangkaian instruksi asli dan memperbarui konteks internal VM, biasanya vpc.
	\item \bi{VM exit:} Perannya untuk transisi dari konteks mesin virtual balik ke konteks eksekusi native.
\end{enumerate}

Proses eksekusi Code Virtualization pada program dapat dilihat pada Gambar \ref{F:execution_virtualization} dan contoh code virtualization pada intel assembly dapat dilihat pada Gambar \ref{F:transformation_virtualization}.

\begin{figure}
	\centering
	\includegraphics[width=0.6\textwidth]
	{\Assets/virtualization_execution.png}
	\caption{Alur eksekusi Code Virtualization \cite{Don20}}
	\label{F:execution_virtualization}
\end{figure}

\begin{figure}
	\centering
	\includegraphics[width=0.6\textwidth]
	{\Assets/code_to_virtualized.png}
	\caption{Transformasi kode asli menjadi kode virtual \cite{Don20}}
	\label{F:transformation_virtualization}
\end{figure}

\subsection{VxLang}
VxLang adalah sebuah proyek obfuscation kode atau biner yang bertujuan untuk mencegah attacker melakukan tindakan reverse engineering, seperti analisis statis atau dinamis, perusakan file, dan akses ilegal ke memori. VxLang ini merupakan sebuah perangkat komprehensif yang terdiri dari packer/protector, alat obfuscation kode, dan alat virtualisasi kode. Proyek ini saat ini menargetkan executable Microsoft Windows PE (.exe/.dll/*.sys dan UEFI) pada x86-64, dengan dukungan untuk Linux ELF dan ARM yang direncanakan di masa mendatang.
\subsubsection{Komponen-Komponen Utama VxLang}
VxLang terdiri dari beberapa komponen utama yang bekerja sama untuk melindungi kode:
\begin{itemize}
	\item \bi{Binary Protector:} Komponen ini memodifikasi, mengompresi, dan mengenkripsi executable asli menjadi format file yang digunakan secara internal oleh VxLang. Binary Protector juga menggabungkan kode inti VxLang, yang dapat diperkuat dan diperluas dengan modul tambahan. Struktur fleksibel ini memungkinkan pengguna untuk dengan bebas memperluas fungsionalitas dan mengontrol inti VxLang.
	\item \bi{Code Obfuscator:} Alat Obfuscation Kode ini mengubah kode native untuk menghalangi analisis, baik dengan memecah blok kode atau meratakan kode ke kedalaman yang sama. Metode obfuscation tambahan akan ditambahkan di masa mendatang. Obfuscation bertujuan untuk membuat kode lebih sulit dipahami tanpa mengubah fungsionalitasnya.
	\item \bi{Code Virtualizer:} Alat Virtualisasi Kode ini mengubah kode menjadi bahasa assembly internal. Bahasa ini kemudian dikonversi menjadi bytecode dan dieksekusi oleh compiler internal. Virtualisasi kode menambahkan lapisan abstraksi yang signifikan, sehingga mempersulit reverse engineering karena attacker harus memahami mesin virtual VxLang untuk dapat memahami kode yang dilindungi.
\end{itemize}

\subsubsection{Arsitektur dan Cara Kerja VxLang}

\begin{itemize}
	\item \bo{Proteksi Biner:} Binary Protector mengambil executable asli dan mengubahnya menjadi format internal VxLang. Proses ini dapat mencakup kompresi untuk mengurangi ukuran file, enkripsi untuk melindungi konten, dan modifikasi struktur file untuk mempersulit analisis statis. Dengan mengubah format file, VxLang mempersulit alat reverse engineering standar untuk memproses dan menganalisis executable.
	\item \bo{Obfuscation Kode:} Code Obfuscator mengubah kode native untuk membuatnya lebih sulit dipahami. Teknik-teknik yang digunakan dapat mencakup:
	      \begin{itemize}
		      \item \bo{Memecah blok kode:} Ini melibatkan pemisahan blok kode yang berurutan menjadi bagian-bagian yang lebih kecil dan menyisipkan lompatan di antara bagian-bagian tersebut. Hal ini mengganggu alur kontrol program dan mempersulit reverse engineer untuk mengikuti logika program.
		      \item \bo{Meratakan kode ke kedalaman yang sama (Code Flattening):} Ini melibatkan pengubahan struktur alur kontrol bersarang (misalnya, loop dan percabangan) menjadi urutan instruksi yang lebih datar. Hal ini menghilangkan hierarki dalam kode dan membuatnya lebih sulit untuk dipahami.
	      \end{itemize}
	      \begin{figure}[!htb]
		      \begin{minipage}{0.5\textwidth}
			      \centering
			      \includegraphics[width=0.8\linewidth]
			      {\Assets/vxlang_before_flattening.PNG}
		      \end{minipage}\hfill
		      \begin{minipage}{0.5\textwidth}
			      \includegraphics[width=1.0\linewidth]
			      {\Assets/vxlang_after_flattening.png}
		      \end{minipage}
		      \caption{Sebelum dan Sesudah \textit{Obfuscation} \cite{VxLang}}
	      \end{figure}
	\item \bo{Virtualisasi kode:} Code Virtualizer mengubah kode native menjadi bytecode untuk mesin virtual VxLang. Bytecode ini kemudian dieksekusi oleh interpreter mesin virtual. Virtualisasi kode menambahkan lapisan abstraksi yang signifikan, karena attacker tidak lagi dapat menganalisis kode native secara langsung. Sebaliknya, mereka harus memahami arsitektur dan set instruksi mesin virtual VxLang, yang tidak terdokumentasi dan dapat dikustomisasi.
	      \begin{figure}
		      \centering
		      \includegraphics[width=0.55\textheight]
		      {\Assets/vxlang_virtualizer.png}
		      \caption{VxLang \textit{Code Virtualizer} \cite{VxLang}}
	      \end{figure}
\end{itemize}

\subsubsection{VxLang SDK dan API untuk Obfuscation}
Untuk menggunakan VxLang, pengembang dapat menggunakan Software Development Kit (SDK) yang tersedia. SDK ini dapat diperoleh dengan mengunduh library yang telah dikompilasi atau dengan mendapatkan kode sumber dari GitHub dan membangunnya sendiri. Setelah mendapatkan SDK, langkah selanjutnya adalah mengatur header dan library links dalam kode proyek. \\

Di dalam header SDK, terdapat beberapa Application Programming Interfaces (API) yang berperan penting dalam melakukan obfuscation kode. API-API ini memungkinkan pengembang untuk menerapkan berbagai teknik obfuscation secara terarah pada kode sumber. Berikut adalah penjelasan mengenai API-API tersebut:

\begin{itemize}
	\item \bo{VL\_OBFUSCATION\_BEGIN/END:} API ini digunakan untuk menambahkan kode dummy (kode palsu) di antara kode asli. Penambahan kode dummy ini bertujuan untuk mengganggu proses disassembly dan decompilation. Disassembly adalah proses menerjemahkan kode mesin kembali ke dalam bentuk assembly, sedangkan decompilation adalah proses menerjemahkan kode mesin atau bytecode ke dalam bahasa pemrograman tingkat tinggi. Dengan adanya kode dummy, reverse engineer akan kesulitan untuk memahami alur eksekusi program yang sebenarnya karena kode dummy tersebut akan muncul dalam hasil disassembly dan decompilation, sehingga mengaburkan kode asli. Contoh penggunaannya dapat dilihat pada Kode \ref{lst:vx_obfuscation_api}.
	      \begin{minted}{cpp}     
          void obfuscation_test(int x) {

            VL_OBFUSCATION_BEGIN;

            printf("Obfuscation Test!")

            VL_OBFUSCATION_END;

          }
    \end{minted}
    \captionof{listing}{Contoh Penggunaan Makro \code{VL\_OBFUSCATION\_BEGIN/END} dari VxLang SDK}
    \label{lst:vx_obfuscation_api}

	\item \bo{VL\_CODE\_FLATTENING\_BEGIN/END:} API ini digunakan untuk mengacak urutan kode pada tingkat kedalaman yang sama. Proses ini juga melibatkan penambahan kode dummy dan membuat kode menjadi lebih sulit diinterpretasikan. Code flattening adalah teknik obfuscation yang mengubah struktur alur kontrol program menjadi lebih datar dan kompleks. Dengan mengacak urutan kode dan menambahkan kode dummy, reverse engineer akan kesulitan untuk merekonstruksi alur logika program yang sebenarnya. Ilustrasi penggunaan makro ini ditunjukkan pada Kode \ref{lst:vx_flattening_api}.
	      \begin{minted}{cpp}     
          void code_flattening_test(int x) {

            VL_CODE_FLATTENING_BEGIN;

            printf("Code Flattening Test!")

            VL_CODE_FLATTENING_END;

          }
    \end{minted}
    \captionof{listing}{Contoh Penggunaan Makro \code{VL\_CODE\_FLATTENING\_BEGIN/END} dari VxLang SDK}
    \label{lst:vx_flattening_api}

	\item \bo{VL\_VIRTUALIZATION\_BEGIN/END:} API ini digunakan untuk mengubah kode native yang ditentukan menjadi bytecode yang hanya dapat diinterpretasikan oleh Central Processing Unit (CPU) internal VxLang. Ini adalah inti dari teknik virtualisasi kode yang ditawarkan oleh VxLang. Kode native yang telah diubah menjadi bytecode tidak lagi dapat dieksekusi secara langsung oleh prosesor fisik, melainkan harus melalui interpreter mesin virtual VxLang. Ini secara signifikan meningkatkan kesulitan reverse engineering karena attacker harus memahami arsitektur dan set instruksi mesin virtual VxLang untuk dapat memahami kode yang dilindungi. Kode \ref{lst:vx_virtualization_api} memberikan contoh implementasinya.
	      \begin{minted}{cpp}     
          void virtualization_test(int x) {

            VL_VIRTUALIZATION_BEGIN;

            printf("Virtualization Test!")

            VL_VIRTUALIZATION_END;

          }
    \end{minted}
    \captionof{listing}{Contoh Penggunaan Makro \code{VL\_VIRTUALIZATION\_BEGIN/END} dari VxLang SDK}
    \label{lst:vx_virtualization_api}

\end{itemize}

API-API ini dapat diterapkan pada kode sumber dengan cara menandai bagian-bagian kode yang ingin diobfuskasi atau divirtualisasi dengan menggunakan API BEGIN dan END yang sesuai.

\subsubsection{Proses Virtualisasi VxLang}
Setelah kode sumber ditandai menggunakan makro SDK dan dikompilasi menjadi \textit{executable intermediate} yang tertaut dengan library VxLang, langkah selanjutnya adalah pemrosesan menggunakan \textit{tool} VxLang. \textit{Tool} ini dijalankan melalui \textit{command-line} secara langsung pada \textit{executable intermediate}. Contohnya:
\begin{verbatim}
    vxlang.exe target_intermediate.exe
\end{verbatim}
\textit{Tool} ini akan menganalisis penanda virtualisasi dalam \textit{executable intermediate}, mengganti kode \textit{native} yang ditandai dengan representasi \textit{bytecode} internal, dan menyematkan \textit{runtime Virtual Machine} (VM) yang diperlukan. Proses ini secara otomatis menghasilkan \textit{executable} akhir yang telah tervirtualisasi, biasanya dengan menambahkan sufiks \texttt{\_vxm} pada nama file asli (misalnya, \texttt{target\_intermediate\_vxm.exe}). \textit{Executable} inilah yang kemudian digunakan untuk distribusi atau pengujian lebih lanjut. Detail mengenai opsi \textit{command-line} lanjutan atau kustomisasi (jika ada) berada di luar cakupan tinjauan ini.

\section{\textit{Graphical User Interface Frameworks}}
Dalam pengembangan aplikasi autentikasi sebagai bagian dari demonstrasi pada penelitian ini, digunakan dua framework antarmuka pengguna grafis (GUI) yang berbeda, yaitu Qt Framework dan Dear ImGUI.

\subsection{\textit{Qt Framework}}
Qt Framework adalah sebuah framework pengembangan aplikasi lintas platform yang sangat populer dan komprehensif. Berdasarkan dokumentasi \cite{Qt}, Qt menyediakan berbagai macam tool dan library yang diperlukan untuk mengembangkan aplikasi dengan antarmuka pengguna yang kaya dan interaktif, serta fungsionalitas non-GUI seperti akses database, jaringan, dan lainnya.

\noindent{\bo{Karakteristik \textit{Qt Framework}:}}
\begin{itemize}
	\item \bi{Cross Platform :} Salah satu keunggulan utama Qt adalah kemampuannya untuk berjalan di berbagai sistem operasi seperti Windows, Linux, macOS, Android, iOS, dan bahkan sistem embedded. Ini memungkinkan pengembang untuk menulis kode sekali dan menjalankannya di berbagai platform tanpa perlu modifikasi signifikan.
	\item \bo{Fitur yang Kaya :} Qt menyediakan berbagai macam widget dan layout untuk membangun antarmuka pengguna yang kompleks dan menarik. Selain itu, Qt juga menawarkan dukungan yang kuat untuk grafik 2D dan 3D, animasi, multimedia, dan integrasi dengan teknologi web.
	\item \bo{Bahasa Pemrograman Utama :} Qt umumnya digunakan dengan bahasa pemrograman C++, namun juga memiliki binding untuk bahasa lain seperti Python (melalui PyQt atau PySide).
\end{itemize}

Dalam konteks ini, Qt Framework digunakan untuk membangun antarmuka pengguna yang lebih tradisional dan mungkin lebih kompleks untuk aplikasi autentikasi. Ini memungkinkan visualisasi alur kerja autentikasi, input pengguna (seperti username dan password), dan tampilan hasil autentikasi dengan cara yang terstruktur dan mudah dipahami.

\begin{figure}
	\centering
	\includegraphics[width=0.15\textheight]
	{\Assets/Qt_logo.png}
	\caption{Qt Logo \cite{Qt}}
\end{figure}

\subsection{\textit{Dear ImGUI}}
Dear ImGUI adalah sebuah library antarmuka pengguna grafis (GUI) immediate mode yang ringan dan tidak memerlukan banyak boilerplate untuk digunakan. Berdasarkan repositori GitHub-nya \cite{ImGui}, Dear ImGUI dirancang untuk fokus pada kesederhanaan dan kemudahan integrasi ke dalam aplikasi yang sudah ada, terutama untuk keperluan debugging, tooling, atau prototipe cepat.

\noindent{\bo{Karakteristik \textit{Dear ImGUI}:}}
\begin{itemize}
	\item \bi{Immediate Mode GUI :} Berbeda dengan retained mode GUI seperti Qt, di mana widget dibuat dan dikelola secara eksplisit, Dear ImGUI bekerja dengan cara menggambar ulang seluruh antarmuka pada setiap frame. Ini membuat pengembangan UI menjadi lebih intuitif dan stateful secara implisit.
	\item \bo{Ringan dan Cepat :} Dear ImGUI memiliki ukuran library yang kecil dan performa yang baik, sehingga cocok untuk aplikasi yang membutuhkan sumber daya minimal atau yang sudah memiliki rendering engine sendiri.
	\item \bo{Fokus pada Fungsionalitas Inti :} Dear ImGUI menyediakan berbagai widget dasar seperti tombol, slider, teks input, dan window, yang cukup untuk membangun antarmuka pengguna yang fungsional untuk keperluan demonstrasi atau tooling.
\end{itemize}

Dear ImGUI digunakan untuk menampilkan informasi atau kontrol yang lebih teknis atau diagnostik terkait dengan proses autentikasi yang dilindungi oleh VxLang. Sifatnya yang ringan dan mudah diintegrasikan mungkin menjadikannya pilihan yang baik untuk menampilkan proses autentikasi.

\section{OpenSSL}
OpenSSL adalah sebuah toolkit yang kuat, berkualitas komersial, dan kaya fitur untuk protokol Transport Layer Security (TLS) dan Secure Sockets Layer (SSL). OpenSSL merupakan fondasi kriptografi open-source yang banyak digunakan dalam berbagai aplikasi dan sistem untuk mengamankan komunikasi melalui jaringan \cite{OpenSSL}.

\noindent{\bo{Karakteristik OpenSSL:}}
\begin{itemize}
	\item \bo{Toolkit Kriptograf :} OpenSSL menyediakan implementasi dari berbagai algoritma kriptografi, termasuk algoritma simetris (seperti AES), algoritma asimetris (seperti RSA dan ECC), fungsi hash kriptografi (seperti SHA-256), dan banyak lagi. Ini menjadikannya pilihan yang fleksibel untuk berbagai kebutuhan keamanan.
	\item \bo{Implementasi Standar Keamanan  :} OpenSSL mengimplementasikan protokol keamanan standar seperti TLS dan SSL, yang digunakan untuk mengenkripsi komunikasi antara klien dan server di internet, seperti pada protokol HTTPS.
\end{itemize}

\begin{figure}
	\centering
	\includegraphics[width=0.25\textheight]
	{\Assets/OpenSSL_logo.png}
	\caption{OpenSSL Logo \cite{OpenSSL}}
\end{figure}

OpenSSL dalam penelitian digunakan untuk menjalankan algoritma enkripsi AES (Advanced Encryption Standard) dengan mode CBC (Cipher Block Chaining) dan panjang kunci 256-bit digunakan dari library OpenSSL. AES adalah algoritma enkripsi simetris yang sangat aman dan banyak digunakan. Mode CBC merupakan salah satu mode operasi blok cipher yang umum digunakan dan memerlukan Initialization Vector (IV) acak untuk setiap proses enkripsi guna meningkatkan keamanan. Panjang kunci 256-bit memberikan tingkat keamanan yang sangat tinggi terhadap serangan brute-force.

Penggunaan enkripsi AES-CBC-256 dari OpenSSL dalam percobaan ini bertujuan untuk mengukur performance overhead (beban kinerja) yang mungkin ditimbulkan oleh penerapan VxLang. Dengan membandingkan waktu eksekusi operasi enkripsi yang sama sebelum dan sesudah kode dilindungi oleh VxLang, dapat dianalisis dampak virtualisasi kode terhadap kinerja aplikasi. Pemilihan algoritma AES-CBC-256 sebagai tolok ukur kemungkinan didasarkan pada popularitasnya, tingkat keamanannya, dan ketersediaannya dalam library OpenSSL yang banyak digunakan.
