\chapter{\babLima}

\section{Analisis Pengujian Autentikasi  VxLang}
\subsection{Analisis Statis}
Analisis statis dilakukan untuk memahami mekanisme autentikasi aplikasi tanpa menjalankan kode. Alat yang digunakan dalam analisis ini adalah Ghidra, sebuah \f{software reverse engineering} yang menyediakan kemampuan \f{disassembly} dan \f{decompilation}. Tujuan utama dari analisis statis ini adalah untuk mengidentifikasi lokasi kode yang menangani proses autentikasi dan mencari potensi celah keamanan yang dapat dimanfaatkan untuk melewati proses tersebut.

\subsubsection{Analisis Aplikasi Non-Virtualized}
Pada aplikasi non-virtualized (konsol, Qt, dan ImGUI), proses analisis dimulai dengan mencari \f{string} yang relevan dengan autentikasi, seperti "Authentication Failed" atau \f{string} yang mungkin digunakan sebagai \f{username} atau \f{password}. Setelah \f{string} tersebut ditemukan, langkah selanjutnya adalah menelusuri referensi silang (\f{cross-references}) untuk melihat di mana \f{string} tersebut digunakan dalam kode program. Hal ini membantu dalam mengidentifikasi fungsi atau blok kode yang bertanggung jawab untuk menampilkan pesan kegagalan autentikasi, yang sering kali berdekatan dengan logika autentikasi itu sendiri.

Sebagai contoh, pada aplikasi \textit{app\_imgui}, analisis \f{disassembly} menggunakan Ghidra mengungkapkan potongan kode berikut:

\begin{listing}[H]
    \begin{minted}{asm}
; (Kode memuat input password ke register, misal RDI) ...

; (Kode memuat password hardcoded "rahman", misal ke alamat yg ditunjuk RDX)

LEA            RDX,[s_rahman_140110551]   = "rahman"
MOV            RCX,RDI
CALL           VCRUNTIME140.DLL::memcmp ; Bandingkan input & hardcoded pwd
CMP            RBX,0x6
TEST           EAX,EAX                  ; Cek hasil memcmp (EAX=0 jika sama)
JNZ            LAB_140003226            ; Lompat ke blok gagal jika EAX != 0

; (Blok kode jika autentikasi berhasil) 

LAB_140003226:  ; Label untuk blok gagal
LEA            RDX,[u_Authentication_Failed_1401104da] ; Load string "Auth Failed"
CALL           qword ptr [->USER32.DLL::MessageBoxW] ; Tampilkan pesan gagal

\end{minted}
\caption{Snippet Assembly: Perbandingan Password dan Lompatan Kondisional (Non-Virtualized)}
\label{lst:asm_static_nonvirt_snippet} % Pastikan label unik jika ada versi lama
\end{listing}

Dalam konteks kode di atas, pemanggilan \code{memcmp} (di operasi \texttt{LEA}) membandingkan password yang dimasukkan pengguna dengan nilai "rahman" yang \textit{hardcoded} pada aplikasinya. Hasilnya diperiksa oleh \code{TEST EAX,EAX} (\texttt{140003216}). Jika password tidak sama, \code{EAX} tidak akan nol, dan instruksi \code{JNZ} (\texttt{140003218}, Jump if Not Zero) akan mengalihkan eksekusi ke \code{LAB\_140003226}, di mana pesan "Authentication Failed" ditampilkan. 

Untuk memvalidasi potensi celah keamanan, instruksi `JNZ LAB\_140003226` dapat diubah (\f{patched}) menjadi `JZ LAB\_140003226` atau instruksi lain yang akan selalu mengarahkan program untuk melewati blok kode yang menampilkan pesan kegagalan autentikasi. Dalam kasus ini, mengubah `JNZ` menjadi `JZ` (Jump if Zero) akan menyebabkan lompatan terjadi hanya jika hasil perbandingan adalah nol (yang menandakan autentikasi berhasil), sehingga secara efektif membalikkan logika dan memungkinkan akses tanpa otorisasi.

Lebih lanjut, analisis pada bagian \f{defined data} (.rdata) juga mengungkapkan adanya \f{string} `"seno"` dan `"rahman"`. Keberadaan \f{string-string} ini sangat mengindikasikan bahwa aplikasi menyimpan \f{username} dan \f{password} secara \f{hard-coded}. Praktik menyimpan kredensial secara langsung dalam kode program sangat berbahaya dari sudut pandang keamanan. String seperti ini mudah ditemukan melalui analisis statis, seperti yang telah dilakukan, sehingga penyerang dapat dengan mudah memperoleh informasi \f{username} dan \f{password} tanpa perlu melakukan \f{reverse engineering} yang mendalam atau menjalankan aplikasi. Dalam kasus ini, \f{username} `"seno"` dan \f{password} `"rahman"` yang ditemukan dalam \f{defined data} dapat dieksploitasi untuk melewati mekanisme autentikasi.

\begin{figure}[H] % Ganti H dengan htbp jika ingin float
	\centering
	\includegraphics[width=0.45\textheight]
	{\Assets/hardcoded_credentials.jpeg}
  \caption{\f{Hardcoded username \& password} pada \f{defined data}}
\end{figure}

Analisis serupa juga dilakukan pada aplikasi konsol dan Qt, di mana pola perbandingan string dan penggunaan instruksi kondisional untuk mengontrol alur program berdasarkan hasil autentikasi juga ditemukan dan dapat dimanipulasi dengan cara yang serupa untuk melewati proses autentikasi.

\subsubsection{Analisis Aplikasi Non-Virtualized (Versi Cloud)}
Untuk mengatasi risiko \f{hard-coded} username dan password, mekanisme autentikasi telah diubah menjadi berbasis \f{cloud}. Dalam versi \f{cloud} ini, aplikasi mengirimkan username dan password dalam format JSON ke server HTTP, yang kemudian melakukan verifikasi terhadap database PostgreSQL. Dengan perubahan ini, username dan password tidak lagi disimpan secara langsung di dalam aplikasi klien.

Meskipun kredensial tidak lagi \f{hard-coded}, analisis statis tetap relevan untuk memahami bagaimana aplikasi klien berinteraksi dengan server. Sebagai contoh, pada aplikasi \textit{console\_cloud}, analisis \f{disassembly} menggunakan Ghidra pada fungsi yang menangani autentikasi menunjukkan potongan kode berikut:

\begin{listing}[H]
    \begin{minted}[linenos=false]{asm}
; ... (Kode setelah fungsi send_login_request kembali, hasil mungkin di AL) ...
MOV      AL, byte ptr [RBP + local_69] ; Ambil hasil boolean?
TEST     AL, 0x1                       ; Cek bit 0 dari AL
JNZ      LAB_14000175d                 ; Lompat jika hasil != 0 (Sukses?)
JMP      LAB_14000178e                 ; Lompat jika hasil == 0 (Gagal?)

LAB_14000175d:  ; Blok kode jika sukses
; ... (Kode menampilkan "Authorized!") ...
jmp      LAB_END_AUTH_CHECK                       ; Lompat ke akhir

LAB_14000178e:  ; Blok kode jika gagal
; ... (Kode menampilkan "Not authorized") ...

\end{minted}
\caption{Snippet Assembly: Pemeriksaan Hasil Autentikasi Cloud (Non-Virtualized)}
\label{lst:asm_static_cloud_snippet} % Pastikan label unik
\end{listing}

Pada kode di atas, instruksi \code{TEST AL, 0x1} kemungkinan memeriksa flag atau nilai boolean yang dikembalikan oleh fungsi autentikasi cloud (misalnya, 1 untuk sukses, 0 untuk gagal). Instruksi \code{JNZ LAB\_14000175d} kemudian mengarahkan alur eksekusi ke blok "Authorized!" jika hasil tes tidak nol (sukses), dan sebaliknya akan jatuh ke \code{JMP LAB\_14000178e} atau langsung mengeksekusi blok "Not authorized". Sama seperti kasus sebelumnya, instruksi \code{JNZ} ini dapat dimanipulasi (misal, diubah menjadi \code{JMP LAB\_14000175d} atau \code{NOP}) untuk memaksa alur ke blok sukses, meskipun server menolak autentikasi. Konteks assembly yang lebih lengkap dapat dilihat pada Lampiran \ref{app:kode_asm} (Kode \ref{lst:asm_static_cloud_full}).

Sama seperti pada kasus \f{hard-coded} sebelumnya, instruksi `JNZ LAB\_14000175d` dapat diubah menjadi `JZ LAB\_14000175d`. Dengan perubahan ini, program akan selalu melompat ke bagian yang menampilkan "Authorized!" tanpa perlu melakukan verifikasi yang sebenarnya dari server. Meskipun username dan password tidak lagi disimpan di dalam aplikasi, logika di sisi klien yang menentukan apakah autentikasi berhasil atau gagal masih dapat dimanipulasi.

Ini menunjukkan bahwa meskipun memindahkan logika autentikasi ke server dan menghindari \f{hard-coded credential} meningkatkan keamanan, sisi klien aplikasi masih dapat menjadi target untuk \f{reverse engineering}. Penyerang dapat memodifikasi aplikasi klien untuk selalu menganggap autentikasi berhasil, meskipun server mungkin menolak permintaan autentikasi. Oleh karena itu, keamanan menyeluruh memerlukan perlindungan tidak hanya pada kredensial tetapi juga pada logika bisnis aplikasi di sisi klien.

Analisis serupa juga dilakukan pada aplikasi konsol dan ImGUI versi \f{cloud}, di mana pola pemeriksaan kondisi dan jump kondisional yang menentukan status autentikasi juga ditemukan dan berpotensi untuk dimanipulasi.

\subsubsection{Analisis Aplikasi Virtualized}

Analisis statis pada aplikasi yang telah divirtualisasi menggunakan VxLang menunjukkan tingkat kesulitan yang jauh lebih tinggi dibandingkan versi non-virtualized. Observasi kualitatif ini didukung secara kuat oleh data kuantitatif yang diperoleh dari ringkasan analisis Ghidra terhadap berbagai aplikasi studi kasus, seperti yang disajikan pada Tabel \ref{tab:ghidra_summary_auth_apps_bab5} dan Tabel \ref{tab:ghidra_summary_benchmark_apps_bab5}. Data komprehensif ini mengungkapkan dampak signifikan virtualisasi terhadap berbagai metrik yang relevan untuk analisis statis.

\noindent \textbf{Legenda untuk Tabel \ref{tab:ghidra_summary_auth_apps_bab5} dan \ref{tab:ghidra_summary_benchmark_apps_bab5}:}
\begin{itemize}
    \item \textbf{Aplikasi}: Nama aplikasi atau benchmark yang diuji.
    \item \textbf{Versi}: Menunjukkan apakah aplikasi adalah versi asli (Non-Virt.) atau versi yang telah divirtualisasi oleh VxLang (Virtualized).
    \item \textbf{Mem. Blocks}: Jumlah Blok Memori (\textit{Memory Blocks}) yang diidentifikasi oleh Ghidra.
    \item \textbf{Instructions}: Jumlah Instruksi Mesin (\textit{Instructions}) yang berhasil di-\textit{disassemble} oleh Ghidra.
    \item \textbf{Def. Data}: Jumlah Data Terdefinisi (\textit{Defined Data}) yang dikenali oleh Ghidra.
    \item \textbf{Functions}: Jumlah Fungsi (\textit{Functions}) yang teridentifikasi oleh Ghidra.
    \item \textbf{Symbols}: Jumlah Simbol (\textit{Symbols}) (misalnya, nama fungsi, variabel global) yang dikenali oleh Ghidra.
    \item \textbf{Data Types}: Jumlah Tipe Data (\textit{Data Types}) yang diidentifikasi oleh Ghidra.
    \item \textbf{Data Cat.}: Jumlah Kategori Data (\textit{Data Categories}) yang diklasifikasikan oleh Ghidra.
    \item \textbf{Perubahan \%}: Persentase perubahan nilai metrik pada versi virtualisasi dibandingkan dengan versi non-virtualisasi. Nilai negatif menunjukkan penurunan.
\end{itemize}

% --- TABEL APLIKASI AUTENTIKASI ---
\begin{table}[H]
    \centering
    \caption{Perbandingan Metrik Analisis Statis Ghidra untuk Aplikasi Autentikasi (Non-Virtualized vs. Virtualized)}
    \label{tab:ghidra_summary_auth_apps_bab5}
    \resizebox{\textwidth}{!}{%
    \begin{tabular}{@{}llrrrrrrr@{}}
        \toprule
        \textbf{Aplikasi} & \textbf{Versi} & \textbf{Mem. Blocks} & \textbf{Instructions} & \textbf{Def. Data} & \textbf{Functions} & \textbf{Symbols} & \textbf{Data Types} & \textbf{Data Cat.} \\
        \midrule
        \multirow{3}{*}{app\_imgui} & Non-Virt. & 9 & 246329 & 11485 & 3005 & 33620 & 420 & 24 \\
                                 \cmidrule(lr){2-9}
                                 & Virtualized & 11 & 157 & 210 & 25 & 98 & 87 & 12 \\
                                 \cmidrule(lr){2-9}
                                 & Perubahan \% & +22.22\% & \bo{-99.94\%} & \bo{-98.17\%} & \bo{-99.17\%} & \bo{-99.71\%} & -79.29\% & -50.00\% \\
        \midrule
        \multirow{3}{*}{app\_imgui\_cloud} & Non-Virt. & 9 & 278461 & 13249 & 4063 & 42807 & 442 & 24 \\
                                 \cmidrule(lr){2-9}
                                 & Virtualized & 11 & 180 & 219 & 25 & 117 & 86 & 12 \\
                                 \cmidrule(lr){2-9}
                                 & Perubahan \% & +22.22\% & \bo{-99.94\%} & \bo{-98.35\%} & \bo{-99.38\%} & \bo{-99.73\%} & -80.54\% & -50.00\% \\
        \midrule
        \multirow{3}{*}{app\_qt} & Non-Virt. & 9 & 6104 & 1578 & 538 & 2113 & 366 & 24 \\
                                 \cmidrule(lr){2-9}
                                 & Virtualized & 11 & 214 & 174 & 25 & 103 & 68 & 8 \\
                                 \cmidrule(lr){2-9}
                                 & Perubahan \% & +22.22\% & \bo{-96.49\%} & \bo{-88.97\%} & \bo{-95.35\%} & \bo{-95.13\%} & -81.42\% & -66.67\% \\
        \midrule
        \multirow{3}{*}{app\_qt\_cloud} & Non-Virt. & 9 & 39844 & 3416 & 1700 & 11920 & 399 & 25 \\
                                 \cmidrule(lr){2-9}
                                 & Virtualized & 11 & 163 & 210 & 24 & 127 & 69 & 8 \\
                                 \cmidrule(lr){2-9}
                                 & Perubahan \% & +22.22\% & \bo{-99.59\%} & \bo{-93.85\%} & \bo{-98.59\%} & \bo{-98.93\%} & -82.71\% & -68.00\% \\
        \midrule
        \multirow{3}{*}{console} & Non-Virt. & 8 & 3090 & 726 & 261 & 1018 & 234 & 18 \\
                                 \cmidrule(lr){2-9}
                                 & Virtualized & 10 & 174 & 146 & 20 & 88 & 60 & 9 \\
                                 \cmidrule(lr){2-9}
                                 & Perubahan \% & +25.00\% & \bo{-94.37\%} & \bo{-79.89\%} & \bo{-92.34\%} & \bo{-91.36\%} & -74.36\% & -50.00\% \\
        \midrule
        \multirow{3}{*}{console\_cloud} & Non-Virt. & 8 & 36024 & 2556 & 1370 & 10529 & 277 & 18 \\
                                 \cmidrule(lr){2-9}
                                 & Virtualized & 10 & 167 & 173 & 20 & 81 & 66 & 9 \\
                                 \cmidrule(lr){2-9}
                                 & Perubahan \% & +25.00\% & \bo{-99.54\%} & \bo{-93.23\%} & \bo{-98.54\%} & \bo{-99.23\%} & -76.17\% & -50.00\% \\
        \bottomrule
    \end{tabular}%
    }
\end{table}
% --- AKHIR TABEL APLIKASI AUTENTIKASI ---

% --- TABEL APLIKASI BENCHMARK & LAINNYA ---
\begin{table}[H]
    \centering
    \caption{Perbandingan Metrik Analisis Statis Ghidra untuk Aplikasi Benchmark dan Lainnya (Non-Virtualized vs. Virtualized)}
    \label{tab:ghidra_summary_benchmark_apps_bab5}
    \resizebox{\textwidth}{!}{%
    \begin{tabular}{@{}llrrrrrrr@{}}
        \toprule
        \textbf{Aplikasi} & \textbf{Versi} & \textbf{Mem. Blocks} & \textbf{Instructions} & \textbf{Def. Data} & \textbf{Functions} & \textbf{Symbols} & \textbf{Data Types} & \textbf{Data Cat.} \\
        \midrule
        \multirow{3}{*}{encryption} & Non-Virt. & 8 & 6282 & 849 & 368 & 1920 & 228 & 17 \\
                                 \cmidrule(lr){2-9}
                                 & Virtualized & 10 & 159 & 155 & 20 & 77 & 62 & 9 \\
                                 \cmidrule(lr){2-9}
                                 & Perubahan \% & +25.00\% & \bo{-97.47\%} & \bo{-81.74\%} & \bo{-94.57\%} & \bo{-95.99\%} & -72.81\% & -47.06\% \\
        \midrule
        \multirow{3}{*}{quick\_sort} & Non-Virt. & 8 & 4370 & 700 & 311 & 1472 & 229 & 17 \\
                                 \cmidrule(lr){2-9}
                                 & Virtualized & 10 & 265 & 146 & 20 & 109 & 60 & 9 \\
                                 \cmidrule(lr){2-9}
                                 & Perubahan \% & +25.00\% & \bo{-93.94\%} & \bo{-79.14\%} & \bo{-93.57\%} & \bo{-92.60\%} & -73.80\% & -47.06\% \\
        \midrule
        \multirow{3}{*}{size} & Non-Virt. & 9 & 698 & 936 & 419 & 2342 & 277 & 18 \\
                                 \cmidrule(lr){2-9}
                                 & Virtualized & 11 & 214 & 155 & 23 & 96 & 68 & 10 \\
                                 \cmidrule(lr){2-9}
                                 & Perubahan \% & +22.22\% & \bo{-69.34\%} & \bo{-83.44\%} & \bo{-94.51\%} & \bo{-95.90\%} & -75.45\% & -44.44\% \\
        \bottomrule
    \end{tabular}%
    }
\end{table}
% --- AKHIR TABEL APLIKASI BENCHMARK & LAINNYA ---

Data kuantitatif yang disajikan pada Tabel \ref{tab:ghidra_summary_auth_apps_bab5} dan Tabel \ref{tab:ghidra_summary_benchmark_apps_bab5} secara konsisten menunjukkan dampak signifikan dari virtualisasi kode menggunakan VxLang terhadap metrik-metrik analisis statis yang dihasilkan oleh Ghidra. Beberapa temuan utama dari data ini adalah:

\begin{itemize}
    \item \textbf{Penurunan Drastis pada Metrik Kritis untuk Analisis:}
    Untuk hampir semua aplikasi yang diuji, terjadi penurunan yang sangat signifikan (umumnya lebih dari \textbf{90\%}, dan seringkali mendekati \textbf{99\%}) pada jumlah \textbf{Instruksi} (\textit{Instructions}), \textbf{Fungsi} (\textit{Functions}), dan \textbf{Simbol} (\textit{Symbols}) yang dapat dikenali oleh Ghidra setelah aplikasi divirtualisasi. Jumlah \textbf{Data Terdefinisi} (\textit{Defined Data}) juga mengalami penurunan drastis, berkisar antara \textbf{79\%} hingga \textbf{98\%}.
    Sebagai contoh spesifik, pada aplikasi \texttt{app\_imgui}, jumlah instruksi yang terdeteksi turun dari 246.329 menjadi hanya 157 (\bo{-99.94\%}), fungsi dari 3.005 menjadi 25 (\bo{-99.17\%}), dan simbol dari 33.620 menjadi 98 (\bo{-99.71\%}). Pola serupa terulang pada aplikasi autentikasi dan benchmark lainnya yang diuji.
    \bo{Penurunan masif ini secara langsung mencerminkan efektivitas VxLang dalam mengaburkan struktur fundamental program pada tingkat biner}. Ghidra, yang dirancang untuk menganalisis instruksi mesin standar (seperti x86-64), tidak mampu menginterpretasikan \textit{bytecode} kustom yang dihasilkan oleh proses virtualisasi VxLang. Akibatnya, sebagian besar kode asli menjadi "tidak terlihat" atau tidak dapat dipahami oleh \textit{disassembler}.

    \item \textbf{Perubahan pada Blok Memori (\textit{Memory Blocks}):}
    Jumlah blok memori menunjukkan peningkatan moderat setelah virtualisasi, umumnya sekitar \textbf{11\%} hingga \textbf{25\%} untuk sebagian besar aplikasi yang tercantum. Peningkatan ini kemungkinan disebabkan oleh penambahan segmen memori baru yang digunakan oleh \textit{Virtual Machine} (VM) VxLang itu sendiri untuk menyimpan \textit{runtime} VM, \textit{bytecode} aplikasi, dan struktur data internal VM.

    \item \textbf{Pengurangan Struktur Data Tambahan:}
    Metrik seperti \textbf{Tipe Data} (\textit{Data Types}) dan \textbf{Kategori Data} (\textit{Data Categories}) juga menunjukkan penurunan yang konsisten, masing-masing berkisar antara \textbf{70\%-80\%} dan \textbf{40\%-60\%} pada aplikasi yang diuji. Ini mengindikasikan bahwa proses virtualisasi juga menyembunyikan atau mengubah cara struktur data internal dan metadata program dikenali oleh Ghidra, lebih lanjut mempersulit pemahaman terhadap organisasi data dalam aplikasi yang dilindungi.

    \item \textbf{Konsistensi di Seluruh Aplikasi yang Dianalisis:}
    Penting untuk dicatat bahwa pola perubahan ini konsisten di berbagai jenis aplikasi yang diuji dan disajikan dalam tabel, yaitu aplikasi autentikasi sederhana (konsol, Qt, ImGui) dan aplikasi \textit{benchmark} (enkripsi, \textit{quick sort}, ukuran). Hal ini menunjukkan bahwa dampak virtualisasi VxLang terhadap hasil analisis statis bersifat umum pada sampel aplikasi yang dipertahankan dalam analisis ini. Pengecualian kecil adalah pada metrik Instruksi untuk aplikasi \texttt{size} yang penurunannya "hanya" \textbf{-69.34\%}, kemungkinan karena sebagian besar ukuran \textit{file} \texttt{size} adalah data mentah yang disematkan, bukan kode yang dapat dieksekusi dan divirtualisasi.

\end{itemize}

Temuan kuantitatif ini secara meyakinkan mendukung observasi kualitatif bahwa \f{code virtualization} menggunakan VxLang sangat efektif dalam menghalangi analisis statis. Dengan menghilangkan atau mengaburkan sebagian besar instruksi, fungsi, simbol, dan data yang dapat dikenali, VxLang memaksa \textit{reverse engineer} untuk menghadapi representasi program yang sangat berbeda dan tidak terdokumentasi. Upaya untuk memahami alur logika, mengidentifikasi bagian kode yang relevan (misalnya, logika autentikasi), atau mencari kerentanan melalui analisis statis konvensional menjadi sangat tidak praktis dan kemungkinan besar tidak akan berhasil tanpa pemahaman mendalam tentang arsitektur internal VM VxLang dan pemetaan \textit{bytecode}-nya.

Kesulitan ini timbul karena, sebagaimana telah diuraikan pada Bab 2 (Sub-bab \ref{subsec:disassembler_statis}), \textit{disassembler} statis seperti Ghidra mengandalkan kemampuannya untuk memetakan urutan byte ke instruksi \textit{assembly} yang diketahui untuk arsitektur target \cite{Sikorski2012, Eilam2011}. Virtualisasi kode menggantikan kode \textit{native} ini dengan \textit{bytecode} dari ISA kustom, yang tidak dapat diinterpretasikan dengan benar oleh Ghidra \cite{Ko2007}. \bo{Hasilnya adalah hilangnya informasi struktural program, seperti yang tercermin dalam penurunan drastis metrik-metrik yang diukur.}

Secara keseluruhan, data kuantitatif dari ringkasan analisis Ghidra ini memberikan bukti kuat bahwa \f{code virtualization} menggunakan VxLang secara signifikan meningkatkan kompleksitas analisis statis, menjadi penghalang utama bagi upaya \f{reverse engineering}.

\subsection{Analisis Dinamis}
Analisis dinamis dilakukan dengan menjalankan aplikasi di bawah \f{debugger} x64dbg untuk mengamati perilaku saat \f{runtime}. Tujuannya adalah untuk memverifikasi temuan dari analisis statis dan memahami bagaimana aplikasi berinteraksi dengan \f{input} pengguna, khususnya dalam proses autentikasi.

\subsubsection{Analisis Aplikasi Non-Virtualized}

Untuk aplikasi non-virtualized, analisis dinamis dilakukan dengan mencari string yang relevan dengan proses autentikasi, seperti username dan password yang ditemukan pada analisis statis ("seno" dan "rahman"). \f{Breakpoint} dipasang pada lokasi di mana \f{string} ini digunakan atau dibandingkan.

Pada aplikasi \textit{app\_qt}, saat dijalankan di bawah x64dbg dan diberikan \f{input} yang salah, \f{debugger} mengarahkan eksekusi ke blok kode berikut:

\begin{listing}[H]
    \begin{minted}[linenos=false]{asm}
; ... (Kode membandingkan input password dengan "rahman" via operator==) ...
; Hasil perbandingan (boolean) mungkin disimpan di AL atau flag register

mov al, byte ptr ss:[rbp-41]  ; Ambil hasil perbandingan
test al, 1                    ; Cek apakah hasilnya true (misal: 1)

; Perhatikan bahwa logika JNE/JE mungkin berbeda tergantung optimasi compiler
; Asumsi: JNE melompat jika perbandingan GAGAL (tidak sama)

jne SHORT failure_label       ; Lompat ke blok GAGAL jika password TIDAK sama
; ... (Kode jika password BENAR) ...

jmp END_OF_AUTH

failure_label:
; ... (Kode setup untuk menampilkan "Authentication Failed" via QMessageBox) ...

lea rdx, qword ptr ds:[<"Authentication Failed">]
; ... (call ke fungsi QMessageBox) ...

\end{minted}
\caption{Snippet Assembly: Lompatan Kondisional Setelah Perbandingan Password (Dinamis, Non-Virtualized)}
\label{lst:asm_dynamic_nonvirt_snippet_rev} % Label disesuaikan
\end{listing}

Instruksi \code{test al, 1} memeriksa hasil perbandingan password. Jika password salah (misalnya, \code{al} adalah 0), instruksi \code{jne failure\_label} (Jump if Not Equal/Zero) akan dieksekusi, mengarahkan program ke blok yang menampilkan "Authentication Failed". Dalam analisis dinamis, \textit{debugger} seperti x64dbg memungkinkan \textit{patching on-the-fly}. Dengan mengubah instruksi \code{jne} menjadi \code{je} (Jump if Equal/Zero) atau \code{jmp} (lompatan tanpa syarat ke blok sukses), pemeriksaan password dapat dilewati secara efektif saat \textit{runtime}. Konteks assembly yang lebih lengkap dari sesi debugging ini dapat dilihat di Lampiran \ref{app:kode_asm} (Kode \ref{lst:asm_dynamic_nonvirt_full}).

Sama seperti pada analisis statis, celah keamanan dapat dieksploitasi dengan memodifikasi alur eksekusi. Dalam x64dbg, instruksi `jne` dapat diubah menjadi `je` (Jump if Equal) secara langsung pada saat \f{runtime}. Dengan melakukan perubahan ini, program akan melompat ke bagian yang seharusnya dijalankan hanya jika autentikasi berhasil, meskipun \f{input} yang diberikan salah. Operasi negasi ini secara efektif melewati pemeriksaan autentikasi.

\subsubsection{Analisis Aplikasi Virtualized}

Analisis dinamis pada aplikasi yang telah divirtualisasi menggunakan VxLang menghadirkan tantangan yang signifikan dibandingkan versi non-virtualized, meskipun beberapa aspek \textit{runtime} dapat diobservasi. Data kuantitatif dari analisis menggunakan x64dbg, seperti yang disajikan pada Tabel \ref{tab:x64dbg_summary_auth_apps_bab5_rev} dan Tabel \ref{tab:x64dbg_summary_benchmark_apps_bab5_rev}, memberikan gambaran lebih lanjut mengenai dampak virtualisasi.

\noindent \textbf{Legenda untuk Tabel \ref{tab:x64dbg_summary_auth_apps_bab5_rev} dan \ref{tab:x64dbg_summary_benchmark_apps_bab5_rev}:}
\begin{itemize}
    \item \textbf{Aplikasi}: Nama aplikasi atau benchmark yang diuji.
    \item \textbf{Versi}: Menunjukkan apakah aplikasi adalah versi asli (Non-VM) atau versi yang telah divirtualisasi oleh VxLang (VM), atau persentase perubahan (Perubahan \%).
    \item \textbf{Instr. Count}: Perkiraan Jumlah Instruksi (\textit{Instruction Count}) yang diobservasi selama sesi analisis dinamis di x64dbg.
    \item \textbf{Mem. Sections}: Jumlah Segmen Memori (\textit{Memory Sections}) yang terdaftar oleh x64dbg.
    \item \textbf{Def. Symbols}: Jumlah Simbol Terdefinisi (\textit{Defined Symbols}) yang dapat diobservasi di x64dbg.
    \item \textbf{Key Str. Found}: Status penemuan \textit{string} kunci relevan saat analisis dinamis (Ya/Tidak/-).
\end{itemize}

% --- TABEL ANALISIS DINAMIS APLIKASI AUTENTIKASI (REVISED) ---
\begin{table}[H]
    \centering
    \caption{Perbandingan Metrik Analisis Dinamis x64dbg untuk Aplikasi Autentikasi (Non-VM vs. VM)}
    \label{tab:x64dbg_summary_auth_apps_bab5_rev}
    \resizebox{\textwidth}{!}{%
    \begin{tabular}{@{}llrrrl@{}}
        \toprule
        \textbf{Aplikasi} & \textbf{Versi} & \textbf{Instr. Count} & \textbf{Mem. Sections} & \textbf{Def. Symbols} & \textbf{Key Str. Found} \\
        \midrule
        \multirow{3}{*}{app\_imgui} & Non-VM & 259046 & 7 & 251 & Ya \\
                                 \cmidrule(lr){2-6}
                                 & VM & 258923 & 10 & 19 & Tidak \\
                                 \cmidrule(lr){2-6}
                                 & Perubahan \% & -0.05\% & +42.86\% & \bo{-92.43\%} & - \\
        \midrule
        \multirow{3}{*}{app\_imgui\_cloud} & Non-VM & 296024 & 7 & 266 & Ya \\
                                 \cmidrule(lr){2-6}
                                 & VM & 295890 & 10 & 20 & Tidak \\
                                 \cmidrule(lr){2-6}
                                 & Perubahan \% & -0.05\% & +42.86\% & \bo{-92.48\%} & - \\
        \midrule
        \multirow{3}{*}{app\_qt} & Non-VM & 8022 & 7 & 209 & Ya \\
                                 \cmidrule(lr){2-6}
                                 & VM & 8011 & 10 & 15 & Tidak \\
                                 \cmidrule(lr){2-6}
                                 & Perubahan \% & -0.14\% & +42.86\% & \bo{-92.82\%} & - \\
        \midrule
        \multirow{3}{*}{app\_qt\_cloud} & Non-VM & 49692 & 7 & 231 & Ya \\
                                 \cmidrule(lr){2-6}
                                 & VM & 49744 & 10 & 19 & Tidak \\
                                 \cmidrule(lr){2-6}
                                 & Perubahan \% & +0.10\% & +42.86\% & \bo{-91.77\%} & - \\
        \midrule
        \multirow{3}{*}{console} & Non-VM & 5797 & 6 & 88 & Ya \\
                                 \cmidrule(lr){2-6}
                                 & VM & 5843 & 9 & 12 & Tidak \\
                                 \cmidrule(lr){2-6}
                                 & Perubahan \% & +0.79\% & +50.00\% & \bo{-86.36\%} & - \\
        \midrule
        \multirow{3}{*}{console\_cloud} & Non-VM & 44223 & 6 & 110 & Ya \\
                                 \cmidrule(lr){2-6}
                                 & VM & 44169 & 9 & 15 & Tidak \\
                                 \cmidrule(lr){2-6}
                                 & Perubahan \% & -0.12\% & +50.00\% & \bo{-86.36\%} & - \\
        \bottomrule
    \end{tabular}%
    }
\end{table}
% --- AKHIR TABEL ANALISIS DINAMIS APLIKASI AUTENTIKASI (REVISED) ---

% --- TABEL ANALISIS DINAMIS APLIKASI BENCHMARK (REVISED) ---
\begin{table}[H]
    \centering
    \caption{Perbandingan Metrik Analisis Dinamis x64dbg untuk Aplikasi Benchmark (Non-VM vs. VM)}
    \label{tab:x64dbg_summary_benchmark_apps_bab5_rev}
    \resizebox{\textwidth}{!}{%
    \begin{tabular}{@{}llrrrl@{}}
        \toprule
        \textbf{Aplikasi} & \textbf{Versi} & \textbf{Instr. Count} & \textbf{Mem. Sections} & \textbf{Def. Symbols} & \textbf{Key Str. Found} \\
        \midrule
        \multirow{3}{*}{encryption} & Non-VM & 8336 & 6 & 94 & Ya \\
                                 \cmidrule(lr){2-6}
                                 & VM & 8207 & 9 & 13 & Tidak \\
                                 \cmidrule(lr){2-6}
                                 & Perubahan \% & -1.55\% & +50.00\% & \bo{-86.17\%} & - \\
        \midrule
        \multirow{3}{*}{quick\_sort} & Non-VM & 6580 & 6 & 83 & Ya \\
                                 \cmidrule(lr){2-6}
                                 & VM & 6492 & 9 & 12 & Tidak \\
                                 \cmidrule(lr){2-6}
                                 & Perubahan \% & -1.34\% & +50.00\% & \bo{-85.54\%} & - \\
        \midrule
        \multirow{3}{*}{size} & Non-VM & 9948 & 7 & 95 & Ya \\
                                 \cmidrule(lr){2-6}
                                 & VM & 9870 & 10 & 12 & Tidak \\
                                 \cmidrule(lr){2-6}
                                 & Perubahan \% & -0.78\% & +42.86\% & \bo{-87.37\%} & - \\
        \bottomrule
    \end{tabular}%
    }
\end{table}
% --- AKHIR TABEL ANALISIS DINAMIS APLIKASI BENCHMARK (REVISED) ---

Observasi utama adalah sebagai berikut:
\begin{itemize}
    \item \textbf{Visibilitas Instruksi \textit{Native} dari \textit{Virtual Machine} (VM) VxLang vs. Jumlah Instruksi Teramati:}
      Sebagaimana diobservasi secara kualitatif, setelah aplikasi tervirtualisasi dimuat sepenuhnya, \bo{x64dbg mampu menampilkan urutan instruksi \textit{native} x86-64 yang valid yang sedang dieksekusi.} Instruksi-instruksi ini adalah bagian dari \textit{interpreter} VM VxLang. Data pada Tabel \ref{tab:x64dbg_summary_auth_apps_bab5_rev} dan Tabel \ref{tab:x64dbg_summary_benchmark_apps_bab5_rev} menunjukkan bahwa "Jumlah Instruksi" yang teramati selama sesi analisis pada versi tervirtualisasi seringkali tidak jauh berbeda dibandingkan versi non-virtualisasi. Perubahannya berkisar antara -1.55\% (pada \texttt{encryption}) hingga +0.79\% (pada \texttt{console}), yang menunjukkan bahwa jumlah total instruksi yang dilalui selama observasi tidak secara drastis berubah.
    \bo{Penting untuk ditekankan bahwa jumlah instruksi ini pada versi VM tidak secara langsung merefleksikan kompleksitas atau kemudahan analisis logika aplikasi asli.} Sebaliknya, angka ini lebih mencerminkan aktivitas VM VxLang itu sendiri dalam menjalankan \textit{bytecode}. Fakta bahwa instruksi \textit{native} VM terlihat tidak berarti logika aplikasi asli menjadi transparan.

    \item \textbf{Peningkatan Jumlah Segmen Memori (\textit{Memory Sections}):}
    Data secara konsisten menunjukkan peningkatan jumlah segmen memori untuk aplikasi yang divirtualisasi, yaitu sekitar \textbf{+42.86\%} untuk aplikasi yang awalnya memiliki 7 segmen memori (seperti \texttt{app\_imgui} dan \texttt{app\_qt}) dan \textbf{+50.00\%} untuk aplikasi yang awalnya memiliki 6 segmen memori (seperti \texttt{console} dan \texttt{encryption}). Peningkatan ini kemungkinan besar disebabkan oleh pemetaan segmen memori tambahan yang diperlukan oleh \textit{runtime} VxLang untuk VM itu sendiri, \textit{bytecode}, dan data internal lainnya.

    \item \textbf{Penurunan Drastis Simbol Terdefinisi (\textit{Defined Symbols}):}
      Salah satu dampak paling signifikan yang teramati secara kuantitatif adalah penurunan jumlah simbol terdefinisi yang dapat diobservasi oleh x64dbg. Untuk semua aplikasi yang diuji, terjadi penurunan drastis, umumnya lebih dari \textbf{85\%} (misalnya, \texttt{app\_imgui} dari 251 menjadi 19 simbol, perubahan \bo{-92.43\%}; \texttt{encryption} dari 94 menjadi 13 simbol, perubahan \bo{-86.17\%}). \bo{Hilangnya informasi simbolik ini sangat mempersulit upaya \textit{reverse engineer} untuk memahami konteks kode, menavigasi antar fungsi, atau mengidentifikasi variabel penting saat analisis dinamis.}

    \item \textbf{Kegagalan Menemukan \textit{String} Kunci (\textit{Key Strings Found}):}
      Metrik ini menunjukkan efektivitas paling jelas dari VxLang dalam analisis dinamis. Untuk \textbf{semua} aplikasi yang divirtualisasi, \textit{string-string} kunci yang relevan dengan autentikasi (seperti "Authentication Failed", "Authorized", atau kredensial jika ada) \textbf{tidak berhasil ditemukan} melalui pencarian memori standar atau referensi \textit{string} di x64dbg saat aplikasi berjalan (ditandai sebagai "Tidak" pada tabel). Sebaliknya, pada semua versi non-virtualisasi, \textit{string} kunci ini dapat ditemukan ("Ya"). \bo{Ini membuktikan bahwa VxLang efektif dalam menyembunyikan atau mengenkripsi konstanta \textit{string} yang ditargetkan, bahkan dari inspeksi memori saat \textit{runtime}.}

    \item \textbf{Kesulitan Utama Tetap pada Abstraksi Logika Aplikasi:}
    Meskipun instruksi \textit{native} dari VM VxLang dapat dilihat, tantangan fundamental dalam analisis dinamis tetap ada: logika aplikasi yang sebenarnya (misalnya, proses perbandingan kredensial dan pengambilan keputusan autentikasi) telah ditransformasi menjadi representasi \textit{bytecode} internal. Seorang analis yang menggunakan x64dbg hanya melihat eksekusi dari instruksi-instruksi VM VxLang, bukan eksekusi langsung dari logika aplikasi dalam bentuk \textit{native} aslinya. Hal ini membuat pemahaman terhadap alur logika aplikasi yang sebenarnya dan identifikasi titik-titik keputusan krusial menjadi sangat sulit tanpa pemahaman mendalam mengenai arsitektur VM VxLang.

    \item \textbf{Kegagalan Upaya \textit{Bypass} Sederhana:}
    Sebagai akibat langsung dari abstraksi logika aplikasi ke dalam VM dan hilangnya informasi kontekstual seperti simbol dan \textit{string} kunci, upaya untuk melakukan \textit{bypass} mekanisme autentikasi melalui teknik \textit{patching runtime} sederhana (seperti memodifikasi satu instruksi \textit{jump} kondisional sebagaimana berhasil dilakukan pada versi non-virtualisasi) menjadi tidak efektif. Titik keputusan logika autentikasi tidak lagi terekspos sebagai instruksi \textit{native} yang mudah diidentifikasi dan dimodifikasi.
\end{itemize}

Temuan kuantitatif dan kualitatif ini selaras dengan prinsip dasar \textit{code virtualization} yang dijelaskan pada Bab 2 (Sub-bab \ref{subsec:disassembler_dinamis}). Meskipun \textit{debugger} dinamis seperti x64dbg dapat me-\textit{disassemble} dan melangkah melalui instruksi \textit{native} dari \textit{interpreter} VM VxLang itu sendiri \cite{Sikorski2012}, logika aplikasi asli yang telah divirtualisasi tetap tersembunyi dalam bentuk \textit{bytecode}. Penurunan drastis simbol yang dapat diobservasi dan kegagalan menemukan \textit{string} kunci secara signifikan menghambat proses analisis.

\bo{Dengan demikian, meskipun instruksi \textit{native} dari VM VxLang dapat diobservasi saat \textit{runtime}, analisis dinamis terhadap bagian kode aplikasi yang telah divirtualisasi dengan VxLang tetap menghadirkan tantangan besar dalam hal melacak data sensitif dan memahami serta memanipulasi alur logika aplikasi inti.} Ini secara signifikan meningkatkan kompleksitas dan waktu yang dibutuhkan untuk melakukan \textit{reverse engineering} yang bertujuan untuk \textit{bypass} atau modifikasi.

\section{Analisis Performa \f{Overhead} VxLang}
Hasil dari percobaan performa overhead dan perubahan ukuran file setelah penerapan virtualisasi kode menggunakan VxLang. Percobaan ini dilakukan pada algoritma Quick Sort dan enkripsi AES-CBC-256.

\subsection{Hasil Pengujian Performa \f{Quick Sort}}
Tabel \ref{tab:quick_sort_performance} menyajikan hasil pengukuran waktu rata-rata dan standar deviasi dari algoritma Quick Sort yang dijalankan sebanyak 100 kali untuk setiap ukuran array, baik sebelum maupun sesudah virtualisasi menggunakan VxLang. 

\begin{table}[H] % Ganti H dengan htbp jika ingin float
    \centering
    \caption{Hasil Pengujian Waktu Eksekusi Quick Sort (ms)}
    \label{tab:quick_sort_performance}
    \begin{tabularx}{\textwidth}{@{}|X|X|X|X|X|@{}}
    \hline
        \multirow{2}{*}{\textbf{Ukuran Array}} & \multicolumn{2}{c|}{\textbf{Tanpa Virtualisasi}} & \multicolumn{2}{c|}{\textbf{Dengan Virtualisasi}}\\
        \cline{2-5}
        & \textbf{Rata-rata Waktu (ms)} & \textbf{Standar Deviasi (ms)} & \textbf{Rata-rata Waktu (ms)} & \textbf{Standar Deviasi (ms)}\\
        \hline
        100                     & 0.01 & 0.00 & 2.74 & 0.38 \\
        \hline
        1,000                   & 0.08 & 0.00 & 27.35 & 1.25 \\
        \hline
        5,000                   & 0.54 & 0.05 & 144.44 & 8.25 \\
        \hline
        10,000                  & 1.24 & 0.08 & 295.77 & 13.68 \\
        \hline
        50,000                  & 6.98 & 0.51 & 1,556.15 & 122.81 \\
        \hline
        100,000                 & 15.12 & 1.26 & 3,080.30 & 303.02 \\
        \hline
        500,000                 & 104.44 & 7.30 & 14,298.92 & 374.98 \\
        \hline
        1,000,000               & 218.32 & 8.10 & 33,292.91 & 4,342.93 \\
        \hline
    \end{tabularx}
\end{table}

\begin{figure}[H] % Ganti H dengan htbp jika ingin float
    \centering
    \begin{tikzpicture}
        \begin{axis}[
            xlabel={Ukuran Array},
            ylabel={Rata-rata Waktu Eksekusi (ms)},
            xmode=log,
            log basis x={10},
            ymode=log,
            log basis y={10},
            legend pos=north west,
            title={Perbandingan Waktu Eksekusi Quick Sort},
            grid=major,
        ]
        \addplot coordinates {
            (100, 0.01)
            (1000, 0.08)
            (5000, 0.54)
            (10000, 1.24)
            (50000, 6.98)
            (100000, 15.12)
            (500000, 104.44)
            (1000000, 218.32)
        };
        \addlegendentry{Tanpa Virtualisasi};

        \addplot coordinates {
            (100, 2.74)
            (1000, 27.35)
            (5000, 144.44)
            (10000, 295.77)
            (50000, 1556.15)
            (100000, 3080.30)
            (500000, 14298.92)
            (1000000, 33292.91)
        };
        \addlegendentry{Dengan Virtualisasi};
        \end{axis}
    \end{tikzpicture}
    \caption{Perbandingan Waktu Eksekusi Algoritma Quick Sort antara Versi Tanpa dan Dengan Virtualisasi VxLang.}
    \label{fig:quick_sort_performance}
\end{figure}

Berdasarkan Tabel \ref{tab:quick_sort_performance} dan Gambar \ref{fig:quick_sort_performance}, terlihat adanya peningkatan waktu eksekusi yang sangat signifikan pada algoritma Quick Sort setelah divirtualisasi menggunakan VxLang. Peningkatan ini konsisten terjadi seiring dengan bertambahnya ukuran array. Sebagai contoh:
\begin{itemize}
    \item Untuk array berukuran 100 elemen, waktu eksekusi rata-rata meningkat dari 0.01 ms menjadi 2.74 ms, yang menunjukkan \textit{overhead} sekitar 27,300\%.
    \item Untuk array berukuran 100.000 elemen, waktu eksekusi meningkat dari 15.12 ms menjadi 3.080.30 ms, dengan \textit{overhead} sekitar 20,272\%.
    \item Untuk array terbesar yang diuji pada versi virtualisasi (1.000.000 elemen), waktu eksekusi meningkat dari 218.32 ms menjadi 33.292.91 ms, menghasilkan \textit{overhead} sekitar 15,150\%.
\end{itemize}
Peningkatan standar deviasi juga menunjukkan bahwa waktu eksekusi pada versi virtualisasi menjadi lebih bervariasi, terutama pada ukuran array yang lebih besar. Hal ini mengindikasikan adanya \textit{overhead} yang substansial dan kurang prediktabilitas yang diperkenalkan oleh mesin virtual VxLang dalam mengeksekusi instruksi virtual dibandingkan dengan eksekusi kode \textit{native}. 

\subsection{Hasil Pengujian Performa Enkripsi AES-CBC-256}
Tabel \ref{tab:aes_performance} menyajikan hasil benchmarking enkripsi AES-CBC-256 dengan 1.000.000 blok data (total 976 MB), sebelum dan sesudah virtualisasi menggunakan VxLang.

\begin{table}[H] % Ganti H dengan htbp jika ingin float
  \centering
  \caption{Hasil Pengujian Performa Enkripsi AES-CBC-256}
  \label{tab:aes_performance}
  \begin{tabular}{|l|c|c|}
    \hline
    \bo{Metrik}                                     & \bo{Tanpa Virtualisasi} & \bo{Dengan Virtualisasi} \\
    \hline
    Total Waktu Enkripsi (ms)                  & 1,878.52            & 9,330.73            \\
    \hline
    Total Waktu Dekripsi (ms)                  & 1,304.75            & 8,649.74            \\
    \hline
    Rata-rata Waktu per Blok Enkripsi (ms)     & 0.00188            & 0.00933             \\ % Dihitung dari total waktu / 1jt blok
    \hline
    Rata-rata Waktu per Blok Dekripsi (ms)     & 0.00130            & 0.00865             \\ % Dihitung dari total waktu / 1jt blok
    \hline
    \textit{Throughput} Enkripsi (MB/s)               & 519.86             & 104.66               \\
    \hline
    \textit{Throughput} Dekripsi (MB/s)               & 748.46             & 112.90               \\
    \hline
    \textit{Throughput} Gabungan (MB/s)               & 634.16             & 108.78               \\
    \hline
  \end{tabular}
\end{table}

Hasil pengujian enkripsi AES-CBC-256  menunjukkan \textit{overhead} performa yang signifikan setelah penerapan VxLang.
\begin{itemize}
    \item Total waktu enkripsi meningkat dari 1,878.52 ms menjadi 9,330.73 ms, yang merupakan peningkatan sekitar 396.7\%.
    \item Total waktu dekripsi mengalami peningkatan dari 1,304.75 ms menjadi 8,649.74 ms, atau sekitar 562.9\%.
\end{itemize}
Peningkatan waktu eksekusi ini berdampak langsung pada penurunan \textit{throughput} (kecepatan pemrosesan data):
\begin{itemize}
    \item \textit{Throughput} enkripsi menurun dari 519.86 MB/s menjadi 104.66 MB/s (penurunan sekitar 79.9\%).
    \item \textit{Throughput} dekripsi menurun dari 748.46 MB/s menjadi 112.90 MB/s (penurunan sekitar 84.9\%).
    \item \textit{Throughput} gabungan (rata-rata enkripsi dan dekripsi) menurun dari 634.16 MB/s menjadi 108.78 MB/s, yang merupakan penurunan sekitar 82.8\%.
\end{itemize}
Hasil ini mengkonfirmasi bahwa virtualisasi kode dengan VxLang memperkenalkan \textit{overhead} yang cukup besar pada operasi komputasi intensif seperti enkripsi. 

\subsection{Hasil Pengujian Ukuran File}
Tabel \ref{tab:file_size} menyajikan ukuran file \f{executable} (dalam KB) untuk berbagai program sebelum dan sesudah virtualisasi menggunakan VxLang.

\begin{table}[htbp]
  \centering
  \caption{Hasil Pengujian Ukuran File (KB)}
  \label{tab:file_size}
  \begin{tabular}{@{}|l|c|c|@{}}
    \hline
    \multirow{2}{*}{\textbf{Program}} & \multicolumn{2}{c|}{\textbf{Ukuran File}} \\
    \cline{2-3} & \bo{Tanpa Virtualisasi} & \bo{Virtualiasi} \\
    \hline
    quick\_sort        & 98       & 1,537     \\
    \hline
    encryption         & 110      & 1,507     \\
    \hline
    size               & 97,771   & 112,324   \\
    \hline
    console            & 92       & 1,577     \\
    \hline
    console\_cloud      & 281      & 1,695     \\
    \hline
    app\_imgui         & 1,675    & 2,330     \\
    \hline
    app\_imgui\_cloud    & 1,860    & 2,418     \\
    \hline
    app\_qt            & 122      & 1,578     \\
    \hline
    app\_qt\_cloud       & 315      & 1,671     \\
    \hline
    Lilith\_Client     & 84       & 1,554     \\
    \hline
  \end{tabular}
\end{table}

Hasil pengukuran ukuran file menunjukkan bahwa penerapan virtualisasi kode menggunakan VxLang secara konsisten meningkatkan ukuran file \textit{executable}.
\begin{itemize}
    \item Untuk program-program kecil dan sederhana seperti \texttt{quick\_sort} (98 KB menjadi 1.537 KB, peningkatan sekitar 15.7x), \texttt{console} (92 KB menjadi 1.577 KB, peningkatan sekitar 17.1x), dan \texttt{Lilith\_Client} (84 KB menjadi 1.554 KB, peningkatan sekitar 18.5x), peningkatannya sangat signifikan, seringkali lebih dari 15 kali lipat.
    \item Untuk aplikasi GUI yang lebih besar atau yang menggunakan library eksternal seperti \texttt{app\_imgui} (1.675 KB menjadi 2.330 KB, peningkatan sekitar 1.39x) dan \texttt{app\_qt\_cloud} (315 KB menjadi 1.671 KB, peningkatan sekitar 5.3x), persentase peningkatannya lebih kecil, namun absolutnya tetap menunjukkan penambahan ukuran yang cukup besar (ratusan hingga ribuan KB).
    \item Aplikasi \texttt{size} yang dirancang dengan aset data tersemat besar (97.771 KB) menunjukkan peningkatan ukuran yang relatif paling kecil secara persentase (menjadi 112.324 KB, peningkatan sekitar 1.15x atau 15\%), namun ini tetap berarti penambahan sekitar 14.5 MB. Ini mengindikasikan bahwa \textit{overhead} utama berasal dari \textit{runtime} VxLang itu sendiri, dan dampaknya lebih terasa pada aplikasi kecil.
\end{itemize}
Peningkatan ukuran ini, kemungkinan besar disebabkan oleh penambahan \textit{interpreter} mesin virtual VxLang dan representasi \textit{bytecode} dari kode asli ke dalam \textit{executable} yang dilindungi. Peningkatan ini konsisten di semua jenis aplikasi yang diuji.

\section{Analisis Aplikasi Potensial Berbahaya dan Malware dengan VxLang}
\label{bab:hasil_penelitian_malware} 

\subsection{Pengujian Fungsionalitas Lilith RAT Tervirtualisasi}
\label{subsec:fungsionalitas_lilith_virtualized}
Bagian ini menyajikan hasil analisis terhadap aplikasi RAT Lilith, baik dalam versi asli maupun versi yang telah divirtualisasi menggunakan VxLang. Analisis berfokus pada pengujian fungsionalitas klien Lilith setelah virtualisasi untuk memastikan integritas operasionalnya, serta dampak virtualisasi terhadap deteksi oleh layanan pemindaian \textit{malware} VirusTotal.

Untuk memastikan bahwa proses virtualisasi menggunakan VxLang tidak merusak fungsionalitas inti dari aplikasi yang kompleks seperti Lilith RAT, sebuah pengujian fungsional secara langsung dilakukan. Skenario pengujian ini dirancang untuk memverifikasi kemampuan operasional dasar klien Lilith yang telah divirtualisasi ketika berinteraksi dengan server Lilith dalam lingkungan jaringan lokal.

\subsubsection{Skenario dan Konfigurasi Pengujian}
Pengujian fungsionalitas Lilith RAT yang telah divirtualisasi dilakukan dengan konfigurasi sebagai berikut:
\begin{itemize}
    \item \bo{Server Lilith:} Dijalankan pada laptop pertama dengan alamat IP lokal \texttt{192.168.1.235}. Server Lilith mendengarkan koneksi masuk pada \textit{port} \texttt{1337}. Aplikasi server yang digunakan adalah versi asli yang tidak dimodifikasi (\texttt{Lilith\_Server.exe}).
    \item \bo{Klien Lilith:} Dijalankan pada laptop kedua, yang berada dalam jaringan lokal yang sama, dengan alamat IP \texttt{192.168.1.15}. Aplikasi klien yang diuji adalah versi yang telah diproses dan divirtualisasi oleh VxLang (\texttt{Lilith\_Client\_vm.vxm.exe}).
    \item \bo{Target Demonstrasi Fungsionalitas:} Untuk mendemonstrasikan kemampuan akses sistem berkas dan eksekusi perintah jarak jauh, sebuah berkas teks bernama \texttt{password.txt} dibuat pada direktori kerja aplikasi klien Lilith di laptop kedua. Berkas ini berisi \textit{string} sederhana: \texttt{"THIS IS A SECRET"}.
\end{itemize}

\subsubsection{Langkah-Langkah Demonstrasi dan Hasil Observasi}
Setelah kedua aplikasi (server Lilith dan klien Lilith yang tervirtualisasi) dijalankan pada masing-masing laptop, serangkaian interaksi dilakukan dari terminal server, dan hasilnya diobservasi:
\begin{enumerate}
    \item \bo{Deteksi Koneksi Klien:} Terminal pada server Lilith segera menampilkan notifikasi bahwa koneksi dari klien telah berhasil dibuat, dengan pesan: \texttt{"Client Connected! ID: 0 | IP: 192.168.1.15"}. Ini mengkonfirmasi bahwa klien tervirtualisasi mampu melakukan inisiasi koneksi jaringan dengan benar.
    \item \bo{Menghubungkan ke Sesi Klien:} Operator di sisi server memasukkan perintah \texttt{connect 0} untuk secara aktif terhubung dan mengontrol sesi klien dengan ID 0.
    \item \bo{Aktivasi Kontrol Jarak Jauh (CMD):} Perintah \texttt{remoteControl cmd} kemudian dimasukkan oleh operator server. Terminal server merespons dengan pesan dari klien: \texttt{"ID [0]: CMD session opened."}, yang menandakan bahwa permintaan untuk membuka sesi \textit{command prompt} jarak jauh pada mesin klien telah berhasil diproses.
    \item \bo{Akses ke Direktori Klien:} Setelah sesi CMD jarak jauh aktif, \textit{prompt command prompt} pada terminal server berubah, menunjukkan bahwa konteks eksekusi kini berada di direktori kerja aplikasi klien pada laptop kedua, yaitu \texttt{C:\textbackslash{}02\_College\textbackslash{}03\_Skripsi\_\textbackslash{}skripsi-project\textbackslash{}bin\textbackslash{}Lilith\_Client\textbackslash{}Release>}.
    \item \bo{Verifikasi Isi Direktori:} Operator server menjalankan perintah \texttt{dir} dalam sesi CMD jarak jauh. Hasil dari perintah ini, yang ditampilkan di terminal server, mencantumkan berkas \texttt{password.txt} dalam daftar isi direktori klien, memvalidasi kemampuan untuk melakukan enumerasi direktori.
    \item \bo{Membaca Isi Berkas Jarak Jauh:} Langkah terakhir adalah menjalankan perintah \texttt{type password.txt} pada terminal server. Perintah ini dieksekusi pada mesin klien, dan isinya (string \texttt{"THIS IS A SECRET"}) berhasil diambil dan ditampilkan kembali pada terminal server.
\end{enumerate}
Seluruh rangkaian interaksi ini, yang menunjukkan keberhasilan server dalam mengontrol klien tervirtualisasi dan mengakses berkasnya, didokumentasikan dalam bentuk tangkapan layar terminal server yang disajikan pada Gambar \ref{fig:lilith_demo_terminal_fungsionalitas}.

\begin{figure}[H]
    \centering
    \includegraphics[width=0.9\textwidth]{\Assets/lilith_demo.png} 
    \caption{Demonstrasi Fungsionalitas Lilith RAT Tervirtualisasi dari Terminal Server: Koneksi, Akses CMD, dan Pembacaan Berkas.}
    \label{fig:lilith_demo_terminal_fungsionalitas}
\end{figure}

\subsubsection{Analisis Hasil Pengujian Fungsionalitas Lilith}
Demonstrasi fungsionalitas ini secara meyakinkan membuktikan bahwa proses virtualisasi kode menggunakan VxLang pada aplikasi Lilith RAT \textbf{tidak mengganggu atau merusak fungsionalitas intinya}. Klien Lilith yang telah divirtualisasi tetap mampu menjalankan operasi-operasi fundamental seperti membangun koneksi jaringan, menerima dan memproses perintah dari server, serta berinteraksi dengan sistem berkas pada mesin klien untuk membaca data.

Temuan ini memiliki implikasi penting. Ini menunjukkan bahwa VxLang, sebagai sebuah teknik proteksi, dapat diterapkan pada aplikasi yang relatif kompleks dengan berbagai modul fungsional (seperti komunikasi jaringan, pemrosesan input/output, dan interaksi sistem operasi) tanpa menyebabkan kegagalan operasional. Kemampuan untuk mempertahankan fungsionalitas asli adalah prasyarat krusial sebelum mengevaluasi lebih lanjut efektivitas keamanan dan dampak performa dari sebuah teknik proteksi perangkat lunak. Jika proteksi merusak fungsi dasar aplikasi, maka teknik tersebut tidak praktis untuk digunakan, terlepas dari seberapa kuat tingkat keamanannya. Dalam kasus ini, Lilith RAT tervirtualisasi tetap menjadi alat yang fungsional, yang berarti analisis terhadap kesulitan \textit{reverse engineering} dan \textit{overhead} performa menjadi relevan dan bermakna.

Penting untuk dicatat bahwa keberhasilan fungsionalitas klien Lilith yang tervirtualisasi ini dicapai setelah melalui beberapa iterasi penyesuaian penempatan makro VxLang. Sebagaimana telah diuraikan pada Bab \ref{subsec:tantangan_makro_lilith}, upaya awal untuk memvirtualisasi blok kode yang lebih besar atau yang melibatkan interaksi I/O jaringan secara langsung dalam lingkup virtualisasi seringkali menyebabkan ketidakstabilan aplikasi atau kegagalan fungsional. Sebagai contoh, pembungkusan langsung seluruh blok \texttt{case} dalam penanganan paket atau pemanggilan fungsi pengiriman data jaringan (\texttt{SendString}) dengan makro virtualisasi mengakibatkan \textit{crash}. Fungsionalitas yang stabil baru tercapai ketika makro virtualisasi diterapkan secara lebih hati-hati dan selektif pada bagian-bagian kode yang lebih terisolasi atau pada level pemanggilan fungsi tertentu yang tidak secara langsung mengelola state I/O kompleks. Temuan ini menyoroti bahwa meskipun virtualisasi dapat diterapkan pada aplikasi kompleks seperti Lilith RAT, prosesnya memerlukan pertimbangan teknis yang mendalam mengenai interaksi antara kode yang divirtualisasi dengan sisa sistem dan batasan dari \textit{tool} virtualisasi itu sendiri.

\subsection{Analisis Deteksi Malware menggunakan VirusTotal}
\label{subsec:analisis_virustotal_all_malware}
Untuk mengevaluasi bagaimana virtualisasi kode VxLang mempengaruhi deteksi oleh perangkat lunak antivirus/antimalware secara lebih luas, sepuluh sampel perangkat lunak—termasuk klien Lilith RAT dan sembilan sampel \textit{malware} lainnya—diunggah ke layanan VirusTotal. Tabel \ref{tab:virustotal_all_malware_bab5} merangkum jumlah deteksi oleh \textit{engine} antivirus VirusTotal untuk setiap sampel sebelum (Non-VM) dan sesudah (VM) diterapkan virtualisasi VxLang. Total jumlah \textit{engine} pemindai yang aktif di VirusTotal saat pengujian adalah 72.

% --- TABEL VIRUSTOTAL UNTUK SEMUA MALWARE (BAB 5) ---
\begin{table}[H]
    \centering
    \caption{Perbandingan Jumlah Deteksi VirusTotal untuk Berbagai Sampel Malware (Non-VM vs. VM dari 72 Engine)}
    \label{tab:virustotal_all_malware_bab5}
    \begin{tabular}{@{}lccc@{}}
        \toprule
        \textbf{Malware} & \textbf{Deteksi Non-VM} & \textbf{Deteksi VM} & \textbf{Perubahan Jumlah Deteksi} \\
        \midrule
        Lilith\_Client    & 22 & 18 & \textbf{-4} \\
        Al-Khaser         & 19 & 15 & \textbf{-4} \\
        donut             & 30 & 19 & \textbf{-11} \\
        DripLoader        & 17 & 16 & \textbf{-1} \\
        FilelessPELoader  & 16 & 21 & \textbf{+5} \\
        JuicyPotato       & 9  & 20 & \textbf{+11} \\
        ParadoxiaClient   & 17 & 16 & \textbf{-1} \\
        PELoader          & 14 & 17 & \textbf{+3} \\
        RunPE-In-Memory   & 12 & 16 & \textbf{+4} \\
        SigLoader         & 16 & 17 & \textbf{+1} \\
        \midrule
        \multicolumn{3}{r}{\textbf{Rata-rata Perubahan Deteksi}} & \textbf{+0.4} \\
        \bottomrule
    \end{tabular}
\end{table}
% --- AKHIR TABEL VIRUSTOTAL ---

Observasi utama dari hasil analisis VirusTotal pada kesepuluh sampel ini adalah:
\begin{itemize}
    \item \textbf{Variasi Dampak Virtualisasi terhadap Deteksi:} Hasil deteksi menunjukkan dampak yang bervariasi antar sampel. Untuk lima dari sepuluh sampel (\textit{Lilith\_Client, Al-Khaser, donut, DripLoader, ParadoxiaClient}), terjadi \textbf{penurunan} jumlah deteksi setelah virtualisasi. Penurunan paling signifikan terlihat pada sampel \textit{donut} (-11 deteksi, dari 30 menjadi 19) dan \textit{Lilith\_Client} serta \textit{Al-Khaser} (keduanya -4 deteksi). Hal ini mengindikasikan bahwa untuk sampel-sampel ini, VxLang kemungkinan berhasil mengaburkan \textit{signature} statis atau heuristik yang dikenali oleh sebagian \textit{engine} antivirus.

    \item \textbf{Peningkatan Deteksi pada Beberapa Sampel:} Sebaliknya, untuk lima sampel lainnya—\textit{FilelessPELoader} (16 menjadi 21), \textit{JuicyPotato} (9 menjadi 20), \textit{PELoader} (14 menjadi 17), \textit{RunPE-In-Memory} (12 menjadi 16), dan \textit{SigLoader} (16 menjadi 17)—terjadi \textbf{peningkatan} jumlah deteksi setelah virtualisasi. Peningkatan paling drastis terlihat pada \textit{JuicyPotato} (+11 deteksi) dan \textit{FilelessPELoader} (+5 deteksi). Fenomena ini menunjukkan bahwa meskipun virtualisasi dapat menyembunyikan \textit{signature} asli dari \textit{malware}, proses virtualisasi itu sendiri atau karakteristik dari \textit{executable} yang tervirtualisasi (misalnya, penggunaan perilaku seperti \textit{packer}, perubahan entropi, atau penambahan segmen kode VM) dapat memicu deteksi oleh \textit{engine} antivirus lain. Beberapa \textit{engine} mungkin menandai \textit{file} yang diproteksi secara umum sebagai mencurigakan atau "\textit{RiskWare}".

    \item \textbf{Tidak Ada Eliminasi Deteksi Total dan Rata-rata Perubahan Minimal:} Meskipun ada perubahan signifikan pada sampel individual, tidak ada sampel yang menjadi sepenuhnya tidak terdeteksi (0 deteksi) setelah virtualisasi. Secara keseluruhan, rata-rata perubahan jumlah deteksi untuk kesepuluh sampel adalah +0.4. Ini mengindikasikan bahwa secara agregat, virtualisasi VxLang pada sampel-sampel ini tidak menghasilkan penurunan deteksi yang signifikan secara umum; dampaknya sangat bergantung pada interaksi antara sampel spesifik, cara VxLang memprosesnya, dan bagaimana berbagai \textit{engine} antivirus merespons terhadap karakteristik \textit{malware} asli versus karakteristik \textit{wrapper} virtualisasi.

    \item \textbf{Perubahan Karakteristik Deteksi (Observasi Kualitatif):} Selain perubahan jumlah deteksi, penting untuk dicatat bahwa label ancaman seringkali berubah. Untuk sampel yang mengalami penurunan deteksi, label bisa berubah dari spesifik (misalnya, nama keluarga malware) menjadi lebih generik (misalnya, "Trojan" umum) atau menjadi deteksi berbasis AI/ML dan heuristik. Untuk sampel yang mengalami peningkatan deteksi, label baru mungkin mencerminkan deteksi terhadap lapisan proteksi VxLang itu sendiri sebagai sesuatu yang mencurigakan atau dikemas.
\end{itemize}

\subsubsection{Pembahasan Hasil Analisis VirusTotal}
Hasil analisis VirusTotal yang beragam ini memberikan perspektif yang lebih bernuansa mengenai efektivitas \textit{code virtualization} sebagai teknik penghindaran deteksi.
\begin{enumerate}
    \item \textbf{Pengaburan \textit{Signature} vs. Deteksi Protektor:} Penurunan deteksi pada separuh sampel menegaskan kemampuan VxLang untuk mengaburkan \textit{signature} statis. Namun, peningkatan deteksi pada separuh sampel lainnya, terutama pada \textit{JuicyPotato} dan \textit{FilelessPELoader}, menunjukkan bahwa lapisan virtualisasi itu sendiri dapat menjadi target deteksi. \textit{Engine} antivirus mungkin dilatih untuk mengenali pola yang dihasilkan oleh \textit{virtualizer} atau \textit{packer} umum, dan VxLang, meskipun bertujuan untuk proteksi, dapat secara tidak sengaja memicu \textit{flag} ini.
    \item \textbf{Ketergantungan pada Sampel Malware dan Proses Virtualisasi:} Efektivitas penghindaran deteksi sangat bergantung pada karakteristik asli \textit{malware} dan bagaimana VxLang berinteraksi dengan struktur kodenya, terutama ketika memproses \textit{executable} biner secara langsung tanpa panduan makro. \textit{Malware} yang sudah sangat diobfuskasi atau memiliki struktur yang kompleks mungkin tidak banyak berubah profil deteksinya, atau bahkan bisa menjadi lebih terdeteksi jika lapisan VxLang menambahkan artefak yang dikenali oleh \textit{engine} antivirus sebagai mencurigakan.
    \item \textbf{Evolusi Teknik Deteksi Antivirus:} \textit{Engine} antivirus terus berkembang. Ketergantungan pada \textit{signature} statis berkurang, sementara analisis heuristik, perilaku, dan AI/ML meningkat. Teknik seperti \textit{code virtualization} mungkin efektif terhadap deteksi berbasis \textit{signature} yang lebih tua, tetapi mungkin kurang efektif atau bahkan kontraproduktif terhadap mekanisme deteksi yang lebih modern yang mencari anomali struktural, perilaku yang mencurigakan dari \textit{software} yang diproteksi, atau bahkan ciri-ciri dari \textit{virtualizer} itu sendiri.
    \item \textbf{Implikasi Keamanan:} Temuan ini menggarisbawahi bahwa meskipun VxLang dapat secara signifikan mempersulit \textit{reverse engineering} manual, dampaknya terhadap deteksi otomatis oleh antivirus bersifat kompleks. Pada beberapa kasus, ia dapat membantu menghindari deteksi berbasis \textit{signature}, namun pada kasus lain, ia justru dapat meningkatkan kecurigaan dari \textit{engine} antivirus. Ini menunjukkan bahwa tidak ada solusi tunggal untuk penghindaran deteksi, dan efektivitasnya harus dievaluasi per kasus.
\end{enumerate}
Secara keseluruhan, analisis VirusTotal pada berbagai sampel \textit{malware} menunjukkan bahwa \textit{code virtualization} dengan \bo{VxLang memiliki dampak yang beragam dan tidak selalu menghasilkan penurunan tingkat deteksi.} Faktor-faktor seperti karakteristik sampel asli dan sensitivitas \textit{engine} antivirus terhadap teknik proteksi memainkan peran penting.
