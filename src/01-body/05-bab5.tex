\chapter{\babLima}

\section{Analisis Pengujian Autentikasi  VxLang}
\subsection{Analisis Statis}
Analisis statis dilakukan untuk memahami mekanisme autentikasi aplikasi tanpa menjalankan kode. Alat yang digunakan dalam analisis ini adalah Ghidra, sebuah \f{software reverse engineering} yang menyediakan kemampuan \f{disassembly} dan \f{decompilation}. Tujuan utama dari analisis statis ini adalah untuk mengidentifikasi lokasi kode yang menangani proses autentikasi dan mencari potensi celah keamanan yang dapat dimanfaatkan untuk melewati proses tersebut.

\subsubsection{Analisis Aplikasi Non-Virtualized}
Pada aplikasi non-virtualized (konsol, Qt, dan ImGUI), proses analisis dimulai dengan mencari \f{string} yang relevan dengan autentikasi, seperti "Authentication Failed" atau \f{string} yang mungkin digunakan sebagai \f{username} atau \f{password}. Setelah \f{string} tersebut ditemukan, langkah selanjutnya adalah menelusuri referensi silang (\f{cross-references}) untuk melihat di mana \f{string} tersebut digunakan dalam kode program. Hal ini membantu dalam mengidentifikasi fungsi atau blok kode yang bertanggung jawab untuk menampilkan pesan kegagalan autentikasi, yang sering kali berdekatan dengan logika autentikasi itu sendiri.

Sebagai contoh, pada aplikasi \textit{app\_imgui}, analisis \f{disassembly} menggunakan Ghidra mengungkapkan potongan kode berikut:

\begin{minted}{asm}
1400032cc 48 8d 15 ... LEA            RDX,[DAT_14011054c]        = 73h  s
1400031d3 48 89 d9     MOV            RCX,RBX
1400031d6 e8 ...       CALL           VCRUNTIME140.DLL::memcmp
1400031db 49 83 fe 04  CMP            R14,0x4
1400031df 74 45        JNZ            LAB_140003226
1400031e1 85 c0        TEST           EAX,EAX
1400031e3 74 41        JNZ            LAB_140003226

140003201 48 8d 15 ... LEA            RDX,[s_rahman_140110551]   = "rahman"
140003208 48 89 f9     MOV            RCX,RDI
14000320b e8 ...       CALL           VCRUNTIME140.DLL::memcmp
140003210 48 83 fb 06  CMP            RBX,0x6
140003214 74 10        JNZ            LAB_140003226
140003216 85 c0        TEST           EAX,EAX
140003218 74 0c        JNZ            LAB_140003226

LAB_140003226:
140003226 48 8b 0d ... MOV            RCX,qword ptr [DAT_140162878]
14000322d e8 ...       CALL           FUN_140100180
140003232 48 8d 15 ... LEA            RDX,[u_Authentication_Failed_1401104da] = u"Authentication Failed"
140003239 4c 8d 05 ... LEA            R8,[u_Login_140110506]      = u"Login"
140003240 48 89 c1     MOV            RCX,RAX
140003243 41 b9 10 00 00 00 MOV            R9D,0x10
140003249 ff 15 ...    CALL           qword ptr [->USER32.DLL::MessageBoxW]
\end{minted}

Dalam konteks kode di atas, kita dapat melihat bahwa program memuat string "rahman" (pada alamat `140003201`) dan kemungkinan string lain (pada alamat `1400032cc`) ke dalam register. Kemudian, fungsi `memcmp` dipanggil, yang umumnya digunakan untuk membandingkan blok memori. Setelah pemanggilan `memcmp`, terdapat operasi `TEST EAX,EAX` yang diikuti oleh instruksi `JNZ LAB\_140003226`. Instruksi `JNZ` (Jump if Not Zero) akan melompat ke label `LAB\_140003226` jika hasil dari `memcmp` tidak nol, yang dalam konteks perbandingan string sering kali menandakan bahwa string yang dibandingkan tidak sama. Pada label `LAB\_140003226`, kita melihat string "Authentication Failed" dimuat dan ditampilkan melalui fungsi `MessageBoxW`.

Berdasarkan analisis ini, dapat disimpulkan bahwa blok kode antara alamat `140003201` dan `140003218` kemungkinan besar merupakan bagian dari logika autentikasi yang membandingkan \f{input} pengguna dengan nilai yang diharapkan ("rahman" dan string lainnya). Jika perbandingan gagal (hasil `memcmp` tidak nol), program akan melompat ke `LAB\_140003226` dan menampilkan pesan "Authentication Failed".

Untuk memvalidasi potensi celah keamanan, instruksi `JNZ LAB\_140003226` pada alamat `140003216` dapat diubah (\f{patched}) menjadi `JZ LAB\_140003226` atau instruksi lain yang akan selalu mengarahkan program untuk melewati blok kode yang menampilkan pesan kegagalan autentikasi. Dalam kasus ini, mengubah `JNZ` menjadi `JZ` (Jump if Zero) akan menyebabkan lompatan terjadi hanya jika hasil perbandingan adalah nol (yang menandakan autentikasi berhasil), sehingga secara efektif membalikkan logika dan memungkinkan akses tanpa otorisasi.

Lebih lanjut, analisis pada bagian \f{defined data} (.rdata) juga mengungkapkan adanya \f{string} `"seno"` dan `"rahman"`. Keberadaan \f{string-string} ini sangat mengindikasikan bahwa aplikasi menyimpan \f{username} dan \f{password} secara \f{hard-coded}. Praktik menyimpan kredensial secara langsung dalam kode program sangat berbahaya dari sudut pandang keamanan. String seperti ini mudah ditemukan melalui analisis statis, seperti yang telah dilakukan, sehingga penyerang dapat dengan mudah memperoleh informasi \f{username} dan \f{password} tanpa perlu melakukan \f{reverse engineering} yang mendalam atau menjalankan aplikasi. Dalam kasus ini, \f{username} `"seno"` dan \f{password} `"rahman"` yang ditemukan dalam \f{defined data} dapat dieksploitasi untuk melewati mekanisme autentikasi.

Analisis serupa juga dilakukan pada aplikasi konsol dan Qt, di mana pola perbandingan string dan penggunaan instruksi kondisional untuk mengontrol alur program berdasarkan hasil autentikasi juga ditemukan dan dapat dimanipulasi dengan cara yang serupa untuk melewati proses autentikasi.

\subsubsection{Analisis Aplikasi Non-Virtualized (Versi Cloud)}
Untuk mengatasi risiko \f{hard-coded} username dan password, mekanisme autentikasi telah diubah menjadi berbasis \f{cloud}. Dalam versi \f{cloud} ini, aplikasi mengirimkan username dan password dalam format JSON ke server HTTP, yang kemudian melakukan verifikasi terhadap database PostgreSQL. Dengan perubahan ini, username dan password tidak lagi disimpan secara langsung di dalam aplikasi klien.

Meskipun kredensial tidak lagi \f{hard-coded}, analisis statis tetap relevan untuk memahami bagaimana aplikasi klien berinteraksi dengan server. Sebagai contoh, pada aplikasi \textit{console\_cloud}, analisis \f{disassembly} menggunakan Ghidra pada fungsi yang menangani autentikasi menunjukkan potongan kode berikut:

\begin{minted}[linenos=false]{asm}
LAB_140001754                                   XREF[1]:      140001752(j)
         140001754 8a 45 bf                    MOV            AL,byte ptr [RBP + local_69]
         140001757 a8 01                      TEST           AL,0x1
         140001759 75 02                      JNZ            LAB_14000175d
         14000175b eb 31                      JMP            LAB_14000178e


                                   LAB_14000175d                                   XREF[1]:      140001759(j)
         14000175d 48 8b 0d                   MOV            RCX,qword ptr [->MSVCP140D.DLL::std::cout]           = 0003ec5e
                                       44 cd 03 00
         140001764 48 8d 15                   LEA            RDX,[s_Authorized!_140037270]                         = "Authorized!"
                                       05 5b 03 00
         14000176b e8 d0 0c 00 00              CALL           FUN_140002440                                         longlong * FUN_140002440(longlon
         140001770 48 89 45 b0                MOV            qword ptr [RBP + local_78],RAX
         140001774 eb 00                      JMP            LAB_140001776



                                   LAB_14000178e                                   XREF[1]:      14000175b(j)
         14000178e 48 8b 0d                   MOV            RCX,qword ptr [->MSVCP140D.DLL::std::cout]           = 0003ec5e
                                       13 cd 03 00
         140001795 48 8d 15                   LEA            RDX,[s_Not_authorized_14003727c]                     = "Not authorized"
                                       e0 5a 03 00
         14000179c e8 9f 0c 00 00              CALL           FUN_140002440                                         longlong * FUN_140002440(longlon
         1400017a1 48 89 45 a8                MOV            qword ptr [RBP + local_80],RAX
         1400017a5 eb 00                      JMP            LAB_1400017a7
\end{minted}

Pada kode di atas, label `LAB\_140001754` kemungkinan merupakan awal dari blok logika autentikasi. Instruksi `TEST AL, 0x1` pada alamat `140001757` memeriksa suatu kondisi (kemungkinan hasil dari komunikasi dengan server). Jika kondisi ini tidak terpenuhi (hasil test tidak nol), program akan melompat ke `LAB\_14000175d` dan mencetak "Authorized!". Jika kondisi terpenuhi (hasil test adalah nol), program akan melompat ke `LAB\_14000178e` dan mencetak "Not authorized".

Sama seperti pada kasus \f{hard-coded} sebelumnya, instruksi `JNZ LAB\_14000175d` pada alamat `140001759` dapat diubah menjadi `JZ LAB\_14000175d`. Dengan perubahan ini, program akan selalu melompat ke bagian yang menampilkan "Authorized!" tanpa perlu melakukan verifikasi yang sebenarnya dari server. Meskipun username dan password tidak lagi disimpan di dalam aplikasi, logika di sisi klien yang menentukan apakah autentikasi berhasil atau gagal masih dapat dimanipulasi.

Ini menunjukkan bahwa meskipun memindahkan logika autentikasi ke server dan menghindari \f{hard-coded credential} meningkatkan keamanan, sisi klien aplikasi masih dapat menjadi target untuk \f{reverse engineering}. Penyerang dapat memodifikasi aplikasi klien untuk selalu menganggap autentikasi berhasil, meskipun server mungkin menolak permintaan autentikasi. Oleh karena itu, keamanan menyeluruh memerlukan perlindungan tidak hanya pada kredensial tetapi juga pada logika bisnis aplikasi di sisi klien.

Analisis serupa juga dilakukan pada aplikasi konsol dan ImGUI versi \f{cloud}, di mana pola pemeriksaan kondisi dan jump kondisional yang menentukan status autentikasi juga ditemukan dan berpotensi untuk dimanipulasi.

\subsubsection{Analisis Aplikasi Virtualized}

Analisis statis pada aplikasi yang telah divirtualisasi menggunakan VxLang menunjukkan tingkat kesulitan yang jauh lebih tinggi. Beberapa observasi signifikan yang ditemukan adalah:

\begin{itemize}
  \item \bo{Hilangnya String yang Terdefinisi:} \f{String-string} yang terkait dengan autentikasi, seperti "Authentication Failed", tidak ditemukan secara eksplisit dalam bagian `.data` dari \f{executable}. Hal ini menyulitkan identifikasi awal dari lokasi kode yang relevan dengan autentikasi.
  \item \bo{Pengurangan Jumlah Data yang Terdefinisi:} Jumlah data yang terdefinisi dalam \f{executable} virtualized berkurang secara drastis (dari sekitar 900 menjadi 130 pada salah satu kasus). Ini mengindikasikan bahwa banyak data dan string mungkin telah dienkripsi atau disembunyikan melalui teknik virtualisasi.
  \item \bo{Operasi yang Tidak Diketahui:} Banyak operasi \f{assembly} yang tidak dikenali atau dikategorikan sebagai '?' oleh \f{disassembler} Ghidra. Hal ini menyulitkan pemahaman alur kontrol program dan fungsi-fungsi yang terlibat dalam proses autentikasi.
  \item \bo{Abstraksi Logika Autentikasi:} Mekanisme virtualisasi VxLang tampaknya telah mengabstraksi logika autentikasi yang sebenarnya. Operasi perbandingan \f{string} dan instruksi kondisional yang jelas terlihat pada aplikasi non-virtualized tidak lagi dapat diidentifikasi dengan mudah.
\end{itemize}

Ketidakhadiran \f{string} autentikasi yang jelas dan banyaknya operasi yang tidak diketahui menyiratkan bahwa VxLang menggunakan teknik virtualisasi kode yang efektif dalam menyembunyikan implementasi internal program. Hal ini mempersulit analisis statis tradisional yang mengandalkan identifikasi \f{string} dan pola \f{assembly} yang umum.

Akibatnya, identifikasi dan manipulasi logika autentikasi melalui analisis statis menjadi sangat sulit pada aplikasi yang divirtualisasi. Meskipun mungkin ada cara lain untuk menganalisis kode yang divirtualisasi, pendekatan yang bergantung pada pencarian \f{string} dan \f{patching} instruksi kondisional secara langsung menjadi tidak efektif dalam kasus ini.

\subsection{Analisis Dinamis}
Analisis dinamis dilakukan dengan menjalankan aplikasi di bawah \f{debugger} x64dbg untuk mengamati perilaku saat \f{runtime}. Tujuannya adalah untuk memverifikasi temuan dari analisis statis dan memahami bagaimana aplikasi berinteraksi dengan \f{input} pengguna, khususnya dalam proses autentikasi.

\subsubsection{Analisis Aplikasi Non-Virtualized}

Untuk aplikasi non-virtualized, analisis dinamis dilakukan dengan mencari string yang relevan dengan proses autentikasi, seperti username dan password yang ditemukan pada analisis statis ("seno" dan "rahman"). \f{Breakpoint} dipasang pada lokasi di mana \f{string} ini digunakan atau dibandingkan.

Pada aplikasi \textit{app\_qt}, saat dijalankan di bawah x64dbg dan diberikan \f{input} yang salah, \f{debugger} mengarahkan eksekusi ke blok kode berikut:

\begin{minted}[linenos=false]{asm}
LEA rax,qword ptr ds:[<"seno">]
mov qword ptr ss:[rbp+48],rax
lea rcx,qword ptr ss:[rbp+A8]
lea rdx,qword ptr ss:[rbp+48]
call <app_qt.bool __cdecl operator==(class QString const &, char const *const &)>
mov cl,al
xor eax,eax
test cl,1
mov byte ptr ss:[rbp-41],al
jne app_qt.7FF7B0724899
jmp app_qt.7FF7B07248B7

LEA rax,qword ptr ds:[<"rahman">]
mov qword ptr ss:[rbp+40],rax
lea rcx,qword ptr ss:[rbp+90]
lea rdx,qword ptr ss:[rbp+40]
call <app_qt.bool __cdecl operator==(class QString const &, char const *const &)>
mov byte ptr ss:[rbp-41],al
mov al,byte ptr ss:[rbp-41]
test al,1
jne app_qt.7FF7B07248C3
jmp app_qt.7FF7B0724988

# app_qt.7FF7B0724988
lea rcx,qword ptr ss:[rbp+4]
mov edx,400
call <app_qt.public: __cdecl QFlags<enum QMessageBox::StandardButton>::QFlags<enum QMessageBox::StandardButton>(enum QMessageBox::StandardButton)>
lea rdx,qword ptr ds:[<"Authentication Failed">]
\end{minted}

Kode di atas menunjukkan bahwa program membandingkan \f{input} dengan string `"seno"` dan `"rahman"` menggunakan operator `==`. Instruksi `jne` (Jump if Not Equal) pada alamat `app\_qt.7FF7B0724899` dan `app\_qt.7FF7B07248C3` menentukan alur eksekusi berdasarkan hasil perbandingan. Jika \f{input} tidak sesuai dengan username atau password yang diharapkan, program akan melompat ke alamat yang pada akhirnya menampilkan pesan "Authentication Failed".

Sama seperti pada analisis statis, celah keamanan dapat dieksploitasi dengan memodifikasi alur eksekusi. Dalam x64dbg, instruksi `jne` dapat diubah menjadi `je` (Jump if Equal) secara langsung pada saat \f{runtime}. Dengan melakukan perubahan ini, program akan melompat ke bagian yang seharusnya dijalankan hanya jika autentikasi berhasil, meskipun \f{input} yang diberikan salah. Operasi negasi ini secara efektif melewati pemeriksaan autentikasi.

\subsubsection{Analisis Aplikasi Virtualized}

Analisis dinamis pada aplikasi yang telah divirtualisasi menggunakan x64dbg menunjukkan tantangan yang serupa dengan analisis statis. Ketika mencari string seperti "Authentication Failed", \f{debugger} sering kali tidak dapat menemukannya dalam memori proses. Hal ini mengindikasikan bahwa string tersebut mungkin tidak disimpan dalam format yang jelas atau mungkin dienkripsi dan didekripsi hanya pada saat digunakan.

Selain itu, x64dbg juga menampilkan banyak operasi dengan kategori ??? yang tidak dapat di-\f{disassemble}. Hal ini mempersulit pemahaman alur eksekusi dan fungsi-fungsi yang terlibat dalam proses autentikasi.

Lebih lanjut, melacak alur eksekusi saat memasukkan username dan password menjadi sangat sulit. Berikut adalah perbandingan \f{section} kode saat menerima \f{input} pada aplikasi konsol non-virtualized dan virtualized:

\bo{Non-Virtualized:}
\begin{minted}[linenos=false]{asm}
call <console.public: __cdecl std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>(void)>
mov rcx,qword ptr ds:[<class std::basic_ostream<char, struct std::char_traits<char>> std::cout>]
lea rdx,qword ptr ds:[<"Enter username: ">]
call <console.class std::basic_ostream<char, struct std::char_traits<char>> & __cdecl std::operator<<<struct std::char_traits<char>>(class std::basic_ostream<char, struct std::char_traits<char>> &, char const *)>
jmp console.7FF68CD5104D
mov rcx,qword ptr ds:[<class std::basic_istream<char, struct std::char_traits<char>> std::cin>]
lea rdx,qword ptr ss:[rbp-28]
call <console.class std::basic_istream<char, struct std::char_traits<char>> & __cdecl std::operator>><char, struct std::char_traits<char>, class std::allocator<char>>(class std::basic_istream<char, struct std::char_traits<char>> &, class std::basic_string<char, struct >
jmp console.7FF68CD5105F
mov rcx,qword ptr ds:[<class std::basic_ostream<char, struct std::char_traits<char>> std::cout>]
lea rdx,qword ptr ds:[<"Enter password: ">]
call <console.class std::basic_ostream<char, struct std::char_traits<char>> & __cdecl std::operator<<<struct std::char_traits<char>>(class std::basic_ostream<char, struct std::char_traits<char>> &, char const *)>
\end{minted}

\bo{Virtualized:}
\begin{minted}[linenos=false]{asm}
00007FF74CD48244 | 3F                      | ???
00007FF74CD48245 | E9 1EEF0400             | jmp console_vm.vxm.7FF74CD97168
00007FF74CD4824A | DBDD                    | fcmovnu st(0),st(5)
00007FF74CD4824C | 3026                    | xor byte ptr ds:[rsi],ah
00007FF74CD4824E | 8F                      | ???
00007FF74CD4824F | EB 03                   | jmp console_vm.vxm.7FF74CD48254
00007FF74CD48251 | DDD8                    | fstp st(0)
\end{minted}

Pada kode yang telah divirtualisasi, terlihat banyak operasi yang dikategorikan sebagai ???. Lebih lanjut, dalam beberapa kasus, register RIP (\f{Instruction Pointer}) tampak "\f{stuck}" pada alamat tertentu di dalam \f{debugger} saat mencoba memasukkan username dan password. Hal ini sangat menyulitkan untuk melacak alur eksekusi dan memahami apa yang sebenarnya terjadi di balik layar. Perilaku ini mengindikasikan bahwa VxLang menggunakan teknik virtualisasi yang kompleks, yang secara signifikan menghambat analisis dinamis menggunakan metode tradisional seperti mencari string dan memantau alur eksekusi secara langsung.

\section{Analisis Performa \f{Overhead} VxLang}
Hasil dari percobaan performa overhead dan perubahan ukuran file setelah penerapan virtualisasi kode menggunakan VxLang. Percobaan ini dilakukan pada algoritma Quick Sort dan enkripsi AES-CBC-256.

\subsection{Hasil Pengujian Performa \f{Quick Sort}}
Tabel \ref{tab:quick_sort_performance} menyajikan hasil pengukuran waktu rata-rata dan standar deviasi dari algoritma Quick Sort yang dijalankan sebanyak 100 kali untuk setiap ukuran array, baik sebelum maupun sesudah virtualisasi menggunakan VxLang.

\begin{table}[htbp]
    \centering
    \caption{Hasil Pengujian Waktu Eksekusi Quick Sort (ms)}
    \label{tab:quick_sort_performance}
    \begin{tabularx}{\textwidth}{@{}|X|X|X|X|X|@{}}
    \hline
        \multirow{2}{*}{\textbf{Ukuran Array}} & \multicolumn{2}{c|}{\textbf{Tanpa Virtualisasi}} & \multicolumn{2}{c|}{\textbf{Virtualisasi}}\\
        \cline{2-5}
        & \textbf{Rata-rata Waktu (ms)} & \textbf{Standar Deviasi (ms)} & \textbf{Rata-rata Waktu (ms)} & \textbf{Standar Deviasi (ms)}\\
        \hline
        100                     & 0.01 & 0.00 & 5.15 & 0.42 \\
        \hline
        1000                    & 0.09 & 0.00 & 53.08 & 5.52 \\
        \hline
        5000                    & 0.61 & 0.09 & 300.64 & 26.13 \\
        \hline
        10000                   & 1.38 & 0.22 & 585.70 & 79.88 \\
        \hline
        50000                   & 8.45 & 0.73 & 3,434.32 & 592.92 \\
        \hline
        100000                  & 17.86 & 1.42 & 6,771.09 & 553.09 \\
        \hline
        500000                  & 106.16 & 5.61 & 29,698.73 & 3,518.63 \\
        \hline
        1000000                 & 216.59 & 9.49 & 45,186.90 & 6,198.38 \\
        \hline
    \end{tabularx}
\end{table}

\begin{figure}[htbp]
    \centering
    \begin{tikzpicture}
        \begin{axis}[
            xlabel={Ukuran Array},
            ylabel={Rata-rata Waktu Eksekusi (ms)},
            xmode=log,
            log basis x={10},
            ymode=log,
            log basis y={10},
            legend pos=north west,
            title={Perbandingan Waktu Eksekusi Quick Sort},
            grid=major,
        ]
        \addplot coordinates {
            (100, 0.01)
            (1000, 0.09)
            (5000, 0.61)
            (10000, 1.38)
            (50000, 8.45)
            (100000, 17.86)
            (500000, 106.16)
            (1000000, 216.59)
        };
        \addlegendentry{Tanpa Virtualisasi};

        \addplot coordinates {
            (100, 5.15)
            (1000, 53.08)
            (5000, 300.64)
            (10000, 585.70)
            (50000, 3434.32)
            (100000, 6771.09)
            (500000, 29698.73)
            (1000000, 45186.90)
        };
        \addlegendentry{Dengan Virtualisasi};
        \end{axis}
    \end{tikzpicture}
    \caption{Perbandingan Waktu Eksekusi Algoritma Quick Sort antara Versi Tanpa dan Dengan Virtualisasi VxLang.}
    \label{fig:quick_sort_performance}
\end{figure}

Berdasarkan Tabel \ref{tab:quick_sort_performance} ,terlihat adanya peningkatan waktu eksekusi yang signifikan pada algoritma Quick Sort setelah divirtualisasi menggunakan VxLang. Peningkatan ini terlihat semakin besar seiring dengan bertambahnya ukuran array. Sebagai contoh, untuk array berukuran 100, waktu eksekusi rata-rata meningkat dari 0.01 ms menjadi 5.15 ms, yang menunjukkan overhead sekitar 51400\%. Untuk array yang lebih besar seperti 1.000.000 elemen, waktu eksekusi meningkat dari 216.59 ms menjadi 45186.90 ms, dengan overhead sekitar 20860\%. Peningkatan standar deviasi juga menunjukkan bahwa waktu eksekusi menjadi lebih bervariasi setelah virtualisasi. Hal ini mengindikasikan adanya overhead yang substansial yang diperkenalkan oleh mesin virtual VxLang dalam mengeksekusi instruksi virtual dibandingkan dengan eksekusi kode native.

\subsection{Hasil Pengujian Performa Enkripsi AES-CBC-256}
Tabel \ref{tab:aes_performance} menyajikan hasil benchmarking enkripsi AES-CBC-256 dengan 1.000.000 blok data, di mana setiap blok berukuran 1024 bytes, sebelum dan sesudah virtualisasi menggunakan VxLang.

\begin{table}[htbp]
  \centering
  \caption{Hasil Pengujian Performa Enkripsi AES-CBC-256}
  \label{tab:aes_performance}
  \begin{tabular}{|l|c|c|}
    \hline
    \bo{Metrik}                                     & \bo{Tanpa Virtualisasi} & \bo{Virtualisasi} \\
    \hline
    Total Waktu Enkripsi (ms)                  & 2,722.96            & 13,193.51            \\
    \hline
    Total Waktu Dekripsi (ms)                  & 2,055.01            & 12,529.90            \\
    \hline
    Rata-rata Waktu per Blok Enkripsi (ms)     & 0.00272            & 0.01319             \\
    \hline
    Rata-rata Waktu per Blok Dekripsi (ms)     & 0.00206            & 0.01253             \\
    \hline
    \textit{Throughput} Enkripsi (MB/s)               & 358.64             & 74.02               \\
    \hline
    \textit{Throughput} Dekripsi (MB/s)               & 475.21             & 77.94               \\
    \hline
    \textit{Throughput} Gabungan (MB/s)               & 416.92             & 75.98               \\
    \hline
  \end{tabular}
\end{table}

Hasil pengujian enkripsi AES-CBC-256 menunjukkan overhead performa yang signifikan setelah penerapan VxLang. Total waktu enkripsi meningkat dari 2,722.96 ms menjadi 13,193.51 ms, yang merupakan peningkatan sekitar 384\%. Total waktu dekripsi juga mengalami peningkatan yang serupa, dari 2,055.01 ms menjadi 12,529.90 ms (sekitar 510\%). Peningkatan ini juga tercermin pada penurunan throughput (kecepatan pemrosesan data). Throughput enkripsi menurun dari 358.64 MB/s menjadi 74.02 MB/s, dan throughput dekripsi menurun dari 475.21 MB/s menjadi 77.94 MB/s. Penurunan throughput gabungan juga signifikan, dari 416.92 MB/s menjadi 75.98 MB/s. Hasil ini mengkonfirmasi bahwa virtualisasi kode dengan VxLang memperkenalkan overhead yang cukup besar pada operasi komputasi intensif seperti enkripsi.

\subsection{Hasil Pengujian Ukuran File}
Tabel \ref{tab:file_size} menyajikan ukuran file executable (dalam KB) untuk berbagai program sebelum dan sesudah virtualisasi menggunakan VxLang.

\begin{table}[htbp]
  \centering
  \caption{Hasil Pengujian Ukuran File (KB)}
  \label{tab:file_size}
  \begin{tabular}{@{}|l|c|c|@{}}
    \hline
    \multirow{2}{*}{\textbf{Program}} & \multicolumn{2}{c|}{\textbf{Ukuran File}} \\
    \cline{2-3} & \bo{Tanpa Virtualisasi} & \bo{Virtualiasi} \\
    \hline
    quick\_sort  & 119                                  & 1,951                               \\
    \hline
    encryption   & 131                                  & 1,834                               \\
    \hline
    size         & 97,802                               & 112,716                             \\
    \hline
    console      & 105                                  & 1,942                               \\
    \hline
    app\_imgui   & 1,773                                & 2,753                               \\
    \hline
    app\_qt      & 145                                  & 1,954                               \\
    \hline
  \end{tabular}
\end{table}

Hasil pengukuran ukuran file menunjukkan bahwa penerapan virtualisasi kode menggunakan VxLang secara umum meningkatkan ukuran file executable. Peningkatan ukuran file sangat signifikan untuk program-program kecil seperti quick\_sort, encryption, dan console, di mana ukurannya meningkat lebih dari sepuluh kali lipat. Untuk aplikasi GUI yang lebih besar seperti app\_imgui dan app\_qt, peningkatan ukuran file juga terlihat, meskipun persentasenya mungkin lebih kecil dibandingkan dengan program yang lebih kecil. Peningkatan ukuran file size relatif lebih kecil, namun tetap signifikan. Peningkatan ukuran ini kemungkinan disebabkan oleh penambahan interpreter mesin virtual VxLang dan bytecode yang dihasilkan ke dalam executable yang dilindungi.
