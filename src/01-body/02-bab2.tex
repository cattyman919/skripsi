%-----------------------------------------------------------------------------%
\chapter{\babDua}
%-----------------------------------------------------------------------------%

%-----------------------------------------------------------------------------%
\section{Perangkat Lunak (\f{Software})}
%-----------------------------------------------------------------------------%
Perangkat lunak adalah serangkaian instruksi, data, atau program yang digunakan untuk mengoperasikan komputer dan menjalankan tugas-tugas tertentu [3]. Perangkat lunak memberikan instruksi kepada perangkat keras (hardware) tentang apa yang harus dilakukan, bertindak sebagai perantara antara pengguna dan perangkat keras. Tanpa perangkat lunak, sebagian besar hardware komputer tidak akan berfungsi. Sebagai contoh, prosesor membutuhkan instruksi dari perangkat lunak untuk melakukan perhitungan, dan monitor membutuhkan driver perangkat lunak untuk menampilkan gambar. Perangkat lunak tidak memiliki wujud fisik dan bersifat intangible, berbeda dengan hardware yang dapat disentuh. Perangkat lunak didistribusikan dalam berbagai bentuk, seperti program yang diinstal pada komputer, aplikasi mobile, aplikasi web, dan embedded systems.

\subsection{Perangkat Lunak Sistem}
Perangkat lunak sistem merupakan fondasi yang memungkinkan perangkat lunak aplikasi dan pengguna berinteraksi dengan perangkat keras [3]. Fungsinya antara lain mengelola sumber daya sistem seperti memori, prosesor, dan perangkat input/output. Perangkat lunak sistem juga menyediakan layanan dasar seperti sistem file, manajemen proses, dan antarmuka pengguna. Contoh perangkat lunak sistem meliputi:

\begin{enumerate}
	\item \bo{Sistem Operasi (\f{Operating System}):} Bertindak sebagai platform untuk menjalankan perangkat lunak aplikasi. Sistem operasi mengelola sumber daya hardware, menyediakan antarmuka pengguna, dan menjalankan layanan sistem. Contoh: Microsoft Windows, macOS, Linux, Android, iOS.

	\item \bo{Driver Perangkat Keras (\f{Device Drivers}):} Program yang memungkinkan sistem operasi untuk berkomunikasi dengan perangkat keras tertentu, seperti printer, kartu grafis, kartu suara, webcam, dan mouse. Setiap perangkat keras membutuhkan driver khusus agar dapat berfungsi dengan baik.

\end{enumerate}

\begin{figure}[!htb]
	\begin{minipage}{0.52\textwidth}
		\centering
		\includegraphics[width=0.8\linewidth]
		{assets/pics/windows.png}
	\end{minipage}\hfill
	\begin{minipage}{0.38\textwidth}
		\includegraphics[width=0.4\linewidth]
		{assets/pics/linux.png}
	\end{minipage}
	\caption{Sistem Operasi Windows \& Linux}
\end{figure}

\subsection{Perangkat Lunak Aplikasi}
Perangkat lunak aplikasi dirancang untuk memenuhi kebutuhan spesifik pengguna [3]. Kategori perangkat lunak aplikasi sangat luas dan beragam, berfokus pada penyelesaian tugas-tugas tertentu untuk pengguna. Perangkat lunak aplikasi berjalan di atas sistem operasi dan memanfaatkan layanan yang disediakan oleh sistem operasi.

\begin{itemize}

	\item \bo{Pengolah Kata (\f{Word Processors}):} Digunakan untuk membuat dan mengedit dokumen teks, memformat teks, menambahkan gambar dan tabel, dan melakukan tugas-tugas pengolah kata lainnya. Contoh: Microsoft Word, Google Docs
	\item \bo{Perangkat Lunak Desain Grafis:} Digunakan untuk membuat dan mengedit gambar, ilustrasi, dan desain visual lainnya. Contoh: Adobe Photoshop, GIMP, Inkscape.

\end{itemize}

\begin{figure}[!htb]
	\begin{minipage}{0.5\textwidth}
		\centering
		\includegraphics[width=0.3\linewidth]
		{assets/pics/word.png}
	\end{minipage}
	\begin{minipage}{0.5\textwidth}
		\includegraphics[width=0.3\linewidth]
		{assets/pics/photoshop.png}
	\end{minipage}
	\caption{Prangkat lunak aplikasi}
\end{figure}

\subsection{Proses Kompilasi dan Eksekusi Perangkat Lunak}
Proses menjalankan perangkat lunak melibatkan dua tahap utama: kompilasi dan eksekusi. Kedua tahap ini penting untuk mengubah kode sumber yang dapat dibaca manusia menjadi instruksi yang dapat dieksekusi oleh mesin. Berikut penjelasan lebih detail, dibagi menjadi dua sub-bagian:

\subsubsection{Proses Kompilasi}
Proses kompilasi mengubah kode sumber (source code) yang ditulis dalam bahasa pemrograman tingkat tinggi menjadi kode mesin (machine code) atau kode objek (object code) [4]. Proses ini melibatkan beberapa tahapan, yang masing-masing dilakukan oleh program utilitas yang berbeda:

\begin{enumerate}
	\item \bo{Preprocessing:} Tahap pertama dalam proses kompilasi adalah preprocessing. Preprocessor menangani direktif-direktif preprocessor yang dimulai dengan simbol \#, seperti \#include dan \#define dalam kode sumber.
	\item \bo{Compilation:} Pada tahap ini, compiler menerjemahkan kode sumber yang telah diproses menjadi assembly code. Assembly code adalah representasi mnemonic dari kode mesin, yang lebih mudah dibaca oleh manusia. Kompiler melakukan analisis sintaks dan semantik untuk memastikan kode sumber valid dan sesuai dengan aturan bahasa pemrograman. Kompiler juga melakukan optimasi kode untuk meningkatkan kinerja program.
	\item \bo{Assembly:} Assembler menerjemahkan assembly code menjadi kode objek (object code). Kode objek adalah representasi biner dari instruksi mesin, tetapi belum siap untuk dieksekusi. Kode objek berisi instruksi mesin dan data, tetapi belum terhubung dengan library eksternal.
	\item \bo{Linking:} Linker menggabungkan kode objek dari berbagai file sumber dan library menjadi satu file executable. Linker menyelesaikan referensi eksternal, mengalokasikan alamat memori untuk variabel dan fungsi, dan menghubungkan kode objek dengan library yang dibutuhkan. Output dari tahap linking adalah file executable yang siap dieksekusi.
\end{enumerate}

\begin{figure}
	\centering
	\includegraphics[width=0.35\textheight]
	{assets/pics/program_compile.png}
	\caption{Alur kompilasi program}
\end{figure}

\subsubsection{Proses Eksekusi}
Setelah program dikompilasi menjadi file executable, proses eksekusi dimulai [5]. Proses eksekusi melibatkan beberapa tahapan yang dilakukan oleh sistem operasi:
\begin{enumerate}
	\item \bo{Loading:} Loader yaitu sebuah komponen dari sistem operasi, memuat file executable ke dalam memori utama (RAM). Loader mengalokasikan ruang memori yang dibutuhkan oleh program, memuat instruksi dan data ke dalam memori, dan menginisialisasi program untuk eksekusi.
	\item \bo{Eksekusi:} Setelah program dimuat ke dalam memori, prosesor mulai mengeksekusi instruksi-instruksi yang terdapat dalam program. Prosesor mengambil instruksi satu per satu dari memori, mendekode instruksi, dan mengeksekusinya. Siklus ini berulang hingga program selesai dijalankan atau dihentikan.
	\item \bo{Terminasi:} Program berakhir ketika mencapai instruksi terminasi atau ketika terjadi kesalahan yang menyebabkan program berhenti secara paksa. Sistem operasi kemudian membebaskan sumber daya yang digunakan oleh program, seperti memori dan file.
\end{enumerate}

\begin{figure}
	\centering
	\includegraphics[height=0.5\textheight]
	{assets/pics/program_execution.png}
	\caption{Alur eksekusi program}
\end{figure}

%-----------------------------------------------------------------------------%
\section{\f{Software Control Flow}}
%-----------------------------------------------------------------------------%
Alur kendali perangkat lunak (software control flow) merupakan aspek fundamental dalam eksekusi program, merepresentasikan urutan instruksi yang dieksekusi oleh prosesor untuk mencapai tujuan fungsionalitas program [6]. Memahami  software control flow adalah krusial dalam analisis kode, terutama dalam reverse engineering karena memungkinkan pemetaan jalur eksekusi, identifikasi bottleneck, dan potensi kerentanan. Dalam konteks ini, control flow bukan hanya sekadar urutan instruksi, tetapi juga representasi logis dari bagaimana program merespons input, kondisi, dan interaksi dengan sistem operasi. Pemahaman yang komprehensif terhadap aspek ini memberikan dasar yang kuat dalam menganalisis perilaku program, baik secara statis melalui analisis kode sumber dan intermediate representation, maupun secara dinamis melalui observasi eksekusi runtime.

\subsection{\f{Control Flow Instructions}}
Instruksi alur kendali (control flow instructions) adalah mekanisme fundamental yang menentukan urutan eksekusi instruksi dalam suatu program [6]. Instruksi ini memungkinkan program untuk membuat keputusan, mengulang blok kode, dan melompat ke bagian kode yang berbeda. Cara instruksi-instruksi ini direpresentasikan dan diimplementasikan sangat bergantung pada tingkat bahasa pemrograman yang digunakan. Secara umum, kita membedakan antara bahasa tingkat tinggi dan bahasa tingkat rendah.

\subsubsection{\f{High Level Languages}}
Bahasa pemrograman tingkat tinggi (high-level languages), seperti Python, Java, C++, dan JavaScript, menyediakan abstraksi yang jauh dari detail hardware. Bahasa-bahasa ini fokus pada kemudahan penulisan dan pemahaman kode oleh programmer, dengan menggunakan sintaks yang lebih dekat dengan bahasa manusia. Instruksi control flow dalam bahasa tingkat tinggi diimplementasikan melalui konstruksi yang intuitif, seperti if, else, for, dan while.

\bi{Conditonal Instructions:}

\begin{itemize}
	\item \bi{if statement:} Memungkinkan program membuat keputusan berdasarkan kondisi.
	\item \bi{if-else statement:} Menyediakan jalur alternatif jika kondisi if tidak terpenuhi.
	\item \bi{switch statement:} Memungkinkan percabangan ke banyak kasus.
\end{itemize}

\bi{Loop Instructions:}

\begin{itemize}
	\item \bi{for loop:} Memungkinkan program membuat keputusan berdasarkan kondisi.
	\item \bi{while loop:} Mengeksekusi blok kode selama kondisi tertentu terpenuhi.
\end{itemize}

\bi{Jump Instructions (Indirect - Function Calls):}

\begin{itemize}
	\item \bi{Function call:} Memindahkan kontrol ke fungsi lain dan kembali setelah selesai.
\end{itemize}

\subsubsection{\f{Low Level Languages}}
Bahasa pemrograman tingkat rendah (low-level languages), seperti Assembly language, bekerja lebih dekat dengan hardware. Instruksi-instruksinya langsung dikodekan ke dalam instruksi mesin yang dapat dieksekusi oleh prosesor. Bahasa tingkat rendah memberikan kontrol yang lebih besar atas hardware, tetapi seringkali lebih kompleks dan sulit untuk dipahami oleh manusia. Instruksi control flow pada tingkat ini melibatkan kode operasi (opcode) yang merepresentasikan operasi jump dan perbandingan secara langsung [7]. Dalam bagian ini, contoh akan difokuskan pada bahasa x86 Assembly.

\bi{Conditonal Instructions:}

\begin{itemize}
	\item \bi{cmp (compare):} Membandingkan dua nilai dan mengatur flags (bendera) kondisi.
	\item \bi{jle, jge, je, jne (conditional jumps):} Melompat ke label lain jika flags kondisi memenuhi syarat.
\end{itemize}

\bi{Loop Instructions (Implementasi dengan Conditional Jumps)}
\begin{itemize}
	\item Menggunakan kombinasi instruksi perbandingan, pengurangan counter, dan conditional jump untuk membuat loop.
\end{itemize}

\bi{Jump Instructions (Direct):}
\begin{itemize}
	\item \bi{jmp (unconditional jump):} Lompat ke label tanpa syarat.
\end{itemize}

\bi{Jump Instructions (Indirect - Function Calls):}
\begin{itemize}
	\item \bi{call:} Melompat ke alamat fungsi dan menyimpan alamat return.
	\item \bi{ret:} Mengembalikan control dari fungsi.
\end{itemize}

\subsection{Control Flow Graph}
Graf Alur Kendali (Control Flow Graph atau CFG) adalah representasi grafis dari alur kendali suatu program. CFG memvisualisasikan bagaimana eksekusi program berjalan melalui berbagai blok kode, menggambarkan urutan eksekusi, percabangan, dan perulangan [8]. CFG sangat penting dalam analisis statis kode, reverse engineering, dan optimisasi kode [9]. Dalam CFG, blok dasar (basic blocks) direpresentasikan sebagai simpul (nodes) dan transisi antar blok dasar direpresentasikan sebagai sisi/garis (edges). Contohnya dapat dilihat pada Gambar BAB II TINJAUAN PUSTAKA.5.

\begin{figure}
	\centering
	\includegraphics[width=1\textwidth]
	{assets/pics/control_flow_graph.png}
	\caption{Control Flow Graph}
\end{figure}

%-----------------------------------------------------------------------------%
\section{Rekayasa balik (\f{Reverse Engineering})}
%-----------------------------------------------------------------------------%
Rekayasa balik (reverse engineering) adalah proses menganalisis suatu sistem, baik perangkat lunak, perangkat keras, atau sistem lainnya, untuk mengidentifikasi komponen-komponennya dan interaksi antar komponen, serta memahami cara kerja sistem tersebut tanpa akses ke dokumentasi asli atau kode sumber [11]. Tujuannya beragam, mulai dari pemahaman fungsionalitas, analisis keamanan untuk menemukan kerentanan, pemulihan desain, hingga modifikasi dan peningkatan sistem. Rekayasa balik dapat diterapkan pada berbagai skenario, misalnya untuk menganalisis malware, memahami format file yang tidak terdokumentasi, mempelajari teknik yang digunakan oleh pesaing atau modifikasi fungsionalitas perangkat lunak.

\subsection{Jenis Analisis Rekayasa Balik}
\begin{enumerate}
	\item Analisis Statis
	      Analisis statis melibatkan pemeriksaan kode tanpa menjalankannya. Analisis statis berfokus pada struktur dan logika kode, mencari pola dan kerentanan [12]. Alat yang digunakan dalam analisis statis meliputi:
	      \begin{itemize}
		      \item \bi{Disassembler:}  Menerjemahkan kode mesin menjadi assembly code, sebuah representasi kode yang lebih mudah dibaca oleh manusia. Contoh: IDA Pro, Ghidra, Radare2.
		      \item \bi{Decompiler:}  Menerjemahkan kode mesin atau bytecode kembali ke kode sumber tingkat tinggi (misalnya, C++ atau Java). Decompiler membantu memahami logika program secara lebih mudah.
		      \item \bi{Code Analysis Tools:}  Alat yang digunakan untuk menganalisis kode secara otomatis, mencari kerentanan keamanan, pola kode yang buruk, dan masalah lainnya.
	      \end{itemize}

	      \begin{figure}
		      \centering
		      \includegraphics[width=.75\textwidth]
		      {assets/pics/program_decompile.png}
		      \caption{Dekompilasi Aplikasi}
	      \end{figure}
	\item Analisis Dinamik
	      Analisis dinamis melibatkan menjalankan program dan mengamati perilakunya. Analisis dinamis berfokus pada bagaimana program berinteraksi dengan lingkungannya, mencari kerentanan runtime dan memahami alur eksekusi [12]. Alat yang digunakan dalam analisis dinamis meliputi:
	      \begin{itemize}
		      \item \bi{Debugger:} Memungkinkan eksekusi program secara terkontrol, memeriksa nilai variabel, dan melacak alur eksekusi. Contoh: x64dbg, OllyDbg, GDB.
		      \item \bi{Profiler:} Mengukur penggunaan sumber daya program, seperti waktu eksekusi, penggunaan memori, dan akses file. Profiler membantu mengidentifikasi bottleneck kinerja.
	      \end{itemize}
\end{enumerate}

\subsection{\f{Tampering}}
\f{Tampering} merupakan suatu proses mengubah kode aplikasi untuk mempengaruhi perilakunya. Contoh Tampering perangkat lunak adalah mengubah kode aplikasi agar dapat melewati proses autentikasi dalam perangkat lunak tersebut. Hal ini dapat dilakukan dengan memodifikasi control flow pada proses autentikasi dalam programnya. \\
\f{Tampering} bisa dilakukan pada berbagai tingkatan dan bagian dari perangkat lunak, termasuk
\begin{itemize}
	\item \bo{Kode biner (\textit{executable code}):} Mengubah instruksi mesin yang dijalankan oleh prosesor. Hal ini bisa digunakan untuk mematikan fitur tertentu, menambahkan fitur baru, mengubah perilaku program, atau menyisipkan kode berbahaya.
	\item \bo{Data} Mengubah data konfigurasi, aset game, atau data sensitif lainnya yang digunakan oleh program.
	\item \bo{Pustaka (\textit{Library}):} Memodifikasi library yang digunakan oleh program untuk mengubah fungsionalitasnya.
	\item \bo{Sumber Daya (\textit{Resources}):} Mengubah teks, gambar, atau elemen lain yang digunakan oleh program.
\end{itemize}


\subsection{Alat-alat untuk Rekayasa Balik}
\begin{itemize}
	\item \bo{IDA Pro (Interactive Disassembler Pro):} Disassembler dan debugger komersial yang sangat populer dan powerful. IDA Pro mendukung berbagai arsitektur prosesor dan sistem operasi, menyediakan antarmuka yang canggih untuk analisis kode, dan mendukung plugin untuk ekstensibilitas [13].
	      \begin{figure}
		      \centering
		      \includegraphics[width=.6\textwidth]
		      {assets/pics/IDA_pro.png}
		      \caption{IDA Pro}
	      \end{figure}
	\item \bo{Ghidra:} Framework reverse engineering open-source yang dikembangkan oleh NSA (National Security Agency). Ghidra menawarkan fitur yang setara dengan IDA Pro, termasuk disassembler, decompiler, dan debugger. Ghidra juga mendukung scripting dan ekstensibilitas melalui plugin [14].
	      \begin{figure}
		      \centering
		      \includegraphics[width=.4\textwidth]
		      {assets/pics/Ghidra.png}
		      \caption{Ghidra}
	      \end{figure}
	\item \bo{x64dbg:} Debugger open-source untuk platform Windows. x64dbg menyediakan antarmuka yang modern dan user-friendly, serta mendukung plugin dan scripting. x64dbg fokus pada analisis malware dan reverse engineering aplikasi Windows. [15]
	      \begin{figure}
		      \centering
		      \includegraphics[width=.5\textwidth]
		      {assets/pics/x64Dbg.png}
		      \caption{x64dbg}
	      \end{figure}
\end{itemize}

%-----------------------------------------------------------------------------%
\section{\f{Obfuscation}}
%-----------------------------------------------------------------------------%
Obfuscation adalah teknik yang digunakan untuk mengubah kode sumber atau kode mesin menjadi bentuk yang lebih sulit dipahami oleh manusia, tanpa mengubah fungsionalitas program. Tujuan utama obfuscation adalah untuk mempersulit analisis dan reverse engineering, melindungi kekayaan intelektual, dan meningkatkan keamanan aplikasi. Obfuscation tidak membuat kode menjadi tidak mungkin untuk di-reverse engineer, tetapi meningkatkan waktu dan usaha yang dibutuhkan untuk melakukannya, sehingga membuat reverse engineering menjadi kurang menarik bagi penyerang

\subsection{Manfaat \f{Obfuscation}}
\begin{itemize}
	\item \bo{Meningkatkan Keamanan:} Obfuscation mempersulit penyerang untuk memahami logika program, menemukan kerentanan, dan memodifikasi kode untuk tujuan jahat. Obfuscation dapat melindungi algoritma penting, kunci enkripsi, dan data sensitif lainnya.
	\item \bo{Melindungi Kekayaan Intelektual:} Obfuscation dapat mempersulit pesaing untuk mencuri kode sumber, meniru fungsionalitas program, dan melanggar hak cipta. Ini penting terutama untuk perangkat lunak komersial dan aplikasi yang mengandung algoritma atau teknologi yang unik.
\end{itemize}

\subsection{Jenis-jenis \f{Obfuscation}}
Obfuscation dapat dilakukan pada diterapkan pada kode sumber, bytecode, atau kode biner.
\subsubsection{Kode Sumber \f{Obfuscation}}
Teknik ini mengubah kode sumber yang dapat dibaca manusia, sehingga sulit dipahami tanpa memengaruhi fungsinya [16].
\begin{itemize}
	\item \bi{Layout obfuscation:} mengubah tampilan kode.
	      \begin{itemize}
		      \item \bi{Scrabling identifiers [17]:} mengubah nama fungsi dan variabel.
		      \item \bi{Changing formatting [18]:} menambahkan atau menghapus spasi putih dan baris baru.
		      \item \bi{Removing comments [18]:} menghapus komentar penjelasan.
	      \end{itemize}
	\item \bi{Data obfuscation:} menyembunyikan cara data disimpan dan diproses.
	      \begin{itemize}
		      \item \bi{Data encocding [19] [20] [21]:} Mengubah representasi data, misalnya mengenkripsi string atau mengubah nilai numerik dengan operasi matematika. Ini membuat data asli sulit dikenali langsung.
		      \item \bi{Instruction Substitution [22] [23]} Mengganti instruksi yang sederhana dengan instruksi yang lebih kompleks atau setara, tetapi lebih sulit dipahami.
		      \item \bi{Mixed boolean arithmetic [24] [25] [26]} Menggunakan operasi boolean (AND, OR, XOR, NOT) yang dikombinasikan dengan operasi aritmatika untuk membuat logika program lebih kompleks dan sulit diurai.
	      \end{itemize}
	\item \bi{Control flow obfuscation:} mempersulit logika program.
	      \begin{itemize}
		      \item \bi{Bogus control flow [27]:} menambahkan kode palsu yang memengaruhi alur kontrol.
		      \item \bi{Opaque predicates [28]:} menyisipkan kode sampah ke dalam pernyataan kondisional.
		      \item \bi{Control Flow flattening [29]:} mengubah struktur program menjadi pernyataan switch yang kompleks.
	      \end{itemize}
\end{itemize}

\subsubsection{\f{Bytecode Obfuscation}}
Bytecode Obfuscation beroperasi pada kode perantara yang dihasilkan setelah kompilasi kode sumber. Hal ini khususnya relevan untuk bahasa seperti Java, .NET, LLVM dimana kode dikompilasi menjadi bytecode dan kemudian dijalankan pada mesin virtual [30] [31]. Tujuannya adalah untuk mempersulit rekayasa balik bytecode menjadi kode sumber dengan mudah.\\
Berikut Teknik-teknik obfuscation pada bytecode :
\begin{itemize}
	\item \bi{Renaming [30] :} Mengubah nama kelas, metode, dan variabel dalam bytecode untuk membuat kode sumber yang didekompilasi lebih sulit dibaca. Misalnya, metode bernama calculateSalary dapat diubah namanya menjadi method1
	\item \bi{Control Flow Obfucsation [30] :} Meggunakna  percabangan yang kompleks, kondisional, dan konstruksi berulang untuk membuat kode yang didekompilasi menjadi non-deterministik dan lebih sulit untuk diikuti
	\item \bi{String Encryption [30] :} Mengenkripsi string yang tertanam dalam bytecode, yang hanya didekripsi saat dijalankan saat dibutuhkan. Hal ini mempersulit pencarian informasi atau data sensitif dengan menganalisis bytecode.
	\item \bi{Dummy Code Insertion [30] :} Menambahkan kode yang tidak memengaruhi logika program, tetapi mempersulit dekompilasi dan analisis
\end{itemize}

\subsubsection{\f{Kode Biner Obfuscation}}
Kode Biner Obfuscation diterapkan pada kode akhir yang dapat dieksekusi mesin. Ini berfokus pada upaya membuat biner sulit dianalisis, dibongkar, dan dipahami. Berikut beberapa teknik yang digunakna untuk obfuscation pada kode biner :
\begin{itemize}
	\item bi{Code Packing [32] :} kode asli yang dapat dieksekusi dikompresi atau dienkripsi menjadi biner yang dikemas, yang juga menyertakan kode bootstrap yang membongkar kode asli ke dalam memori saat runtime, sehingga melindungi kode asli dari analisis statis.
	\item bi{Obfuscated Control Flow [32] :} Menggunakan inderect calls dan  jumps, dan memanipulasi instruksi panggilan dan ret untuk mempersulit mengikuti jalur eksekusi program.
	\item bi{Chunked Control Flow [32] :} Membagi kode menjadi blok-blok yang sangat kecil dengan instruksi lompatan antar blok untuk mengganggu pembongkaran linear assembly.
	\item bi{Obfuscated Constants [32] :} Menyembunyikan nilai konstan yang digunakan dalam kode melalui berbagai operasi aritmatika atau logika.
	\item bi{Code Virtualization [32] :} Menerjemahkan kode mesin menjadi instruksi virtual yang dieksekusi oleh mesin virtual khusus yang tertanam dalam aplikasi.
\end{itemize}

\begin{figure}
	\centering
	\includegraphics[width=.8\textwidth]
	{assets/pics/code_virtualization_process.png}
	\caption{Prosess Code Virtualization [1]}
\end{figure}
%-----------------------------------------------------------------------------%
\section{\f{Code Virtualization}}
%-----------------------------------------------------------------------------%

Code Virtualization atau juga disebut dengan VM-Based Code Obfuscation menerupakan suatu teknik obfuscation dimana kita menerjemahkan kode biner orignal menjadi bytecode baru berdasarkan Instruction Set Architecture (ISA) khusus (Gambar BAB II TINJAUAN PUSTAKA.10). Bytecode ini dapat dijalankan secara run-time dengan mesin virtual (i.e. intrepreter) yang tertanam pada aplikasinya [33]. Teknik Code virtualization tidak akan mengembalikan sumber kode aslinya dalam memori sedangkan teknik Code Encryption tetap mengembalikan kodenya aslinya dalam memori saat dilakukan dekripsinya [34].

Set instruksi virtual ini merupakan kunci dari obfuscationnya yang digunakan untuk mapping relasi antara intruksi lokal dan instruksi virtual [33]. Intruksi virtual ini membuat aliran kontrol dari original program untuk tidak dapat dibaca dan mempersulit reverse-engineer program. Code Virtualization dapat menghasilkan berbagai mesin virtual dengan set instruksi virtual masing-masing. Dengan ini, setiap copy dari program dapat memiliki instruksi virtual khusus agar mencegah penyerang untuk mengenali opcode mesin virtual menggunakan metode Frequency Analysis [1] [33].

\begin{figure}
	\centering
	\includegraphics[width=1\textwidth]
	{assets/pics/multiple_virtualization.jpg}
	\caption{Transformasi ISA x86 menjadi berbagai messin virtual [1]}
\end{figure}

Arsitektur umum mesin virtual untuk Code Virtualization memiliki komponen-komponen yang mirip dengan design CPU [35] [36]
\begin{enumerate}
	\item \bi{VM entry:} Perannya untuk simpan konteks eksekusi native (seperti register CPU atau flag) dan transisi ke konteks mesin virtual.
	\item \bi{Fetch:} Perannya adalah untuk mengambil, dari memori internal VM, opcode (virtual) yang akan ditiru, berdasarkan nilai Virtual Program Counter (vpc).
	\item \bi{Decode:} Perannya adalah untuk mendekode opcode yang diambil dan operan yang sesuai untuk menentukan instruksi ISA mana yang akan dieksekusi.
	\item \bi{Dispatch:} Setelah instruksi didekodekan, operator menentukan pengendali mana yang harus dijalankan dan mengatur konteksnya.
	\item \bi{Handlers:} Meniru instruksi virtual melalui rangkaian instruksi asli dan memperbarui konteks internal VM, biasanya vpc.
	\item \bi{VM exit:} Perannya untuk transisi dari konteks mesin virtual balik ke konteks eksekusi native.
\end{enumerate}

Proses eksekusi Code Virtualization pada program dapat dilihat pada Gambar BAB II TINJAUAN PUSTAKA.12 dan contoh code virtualization pada intel assembly dapat dilihat pada Gambar BAB II TINJAUAN PUSTAKA.13.

\begin{figure}
	\centering
	\includegraphics[width=0.7\textwidth]
	{assets/pics/virtualization_execution.png}
	\caption{Alur eksekusi Code Virtualization [34]}
\end{figure}

\begin{figure}
	\centering
	\includegraphics[width=0.7\textwidth]
	{assets/pics/code_to_virtualized.png}
	\caption{Transformasi kode asli menjadi kode virtual [34]}
\end{figure}

\subsection{EagleVM}
EagleVM adalah implementasi code virtualization open-source untuk arsitektur x86-64 yang dirancang khusus untuk tujuan penelitian dan demonstrasi [2]. Proyek ini merupakan hasil kompilasi penelitian dari Code Virtualizer komersial seperti VMProtect, Themida, dan Enigma Protector [1] [37] [38]. Proyek ini berfokus pada transformasi biner-ke-biner (bin2bin), memungkinkan modifikasi langsung pada file executable tanpa memerlukan akses ke kode sumber. EagleVM menyediakan kerangka kerja yang fleksibel untuk mempelajari dan mengembangkan teknik virtualisasi kode, serta menawarkan kemampuan untuk melindungi bagian-bagian tertentu dari kode program dari analisis reverse-engineering. Meskipun bersifat open-source dan bermanfaat untuk riset, EagleVM tidak didesain untuk penggunaan produksi dan memiliki keterbatasan dalam hal stabilitas dan fitur.

\subsubsection{Komponen EagleVM}
EagleVM memiliki arsitektur modular yang terdiri dari beberapa komponen yang bekerja sama [2]:
\begin{itemize}
	\item \bo{EagleVM (Core):} Inti dari EagleVM, berisi logika utama untuk memproses biner input, melakukan disassembly, menerjemahkan instruksi x86-64 ke bytecode, dan menghasilkan biner output yang mengandung mesin virtual dan bytecode. Komponen ini juga bertanggung jawab untuk mengelola konteks eksekusi, termasuk pemetaan register dan stack.
	\item \bo{EagleVM.Stub:} Dynamic Link Library (DLL) yang berperan penting dalam proses penandaan kode yang akan divirtualisasi. DLL ini mengekspor dua fungsi utama, yaitu fnEagleVMBegin dan fnEagleVMEnd. Pengembang menggunakan fungsi-fungsi ini di dalam kode sumber mereka untuk menandai awal dan akhir blok kode yang akan dilindungi dengan virtualisasi. EagleVM kemudian akan mencari panggilan ke fungsi-fungsi ini dalam biner input untuk mengidentifikasi bagian kode yang harus divirtualisasi.
	\item \bo{EagleVM.Sandbox:} Sebuah aplikasi contoh yang berfungsi sebagai sandbox untuk mendemonstrasikan cara menggunakan EagleVM dan EagleVM.Stub. Proyek ini memberikan contoh konkret tentang bagaimana mengintegrasikan EagleVM ke dalam alur kerja pengembangan perangkat lunak dan bagaimana memanfaatkan fitur-fitur yang disediakan oleh EagleVM.Stub untuk menandai kode yang akan divirtualisasi.
\end{itemize}

\subsubsection{Arsitektur Mesin Virtual EagleVM}
Mesin virtual EagleVM didesain dengan mempertimbangkan kesederhanaan dan kemudahan implementasi, sambil tetap memberikan perlindungan yang memadai terhadap reverse engineering. Arsitekturnya menyerupai arsitektur CPU sederhana, dengan komponen-komponen utama sebagai berikut:
\begin{itemize}
	\item \bo{Konteks x86-64 dan VM:} Saat memasuki mesin virtual, konteks x86-64 asli (nilai register dan stack pointer) disimpan di stack. EagleVM kemudian mengalokasikan ruang di stack untuk konteks mesin virtual, termasuk register virtual dan virtual call stack. Register R0-R15 x86-64 kemudian dapat digunakan oleh mesin virtual. Dokumentasi EagleVM menyebutkan bahwa register RFLAGS selalu disimpan pertama di stack karena otomatisasi dalam pembuatan VMENTER dan VMEXIT.
	\item \bo{Register Virtual} EagleVM menggunakan sejumlah register virtual untuk eksekusi bytecode. Beberapa register virtual yang penting meliputi:
	      \begin{itemize}
		      \item VIP (Virtual Instruction Pointer): Analog dengan RIP pada x86-64, menunjuk ke instruksi virtual selanjutnya yang akan dieksekusi.
		      \item VSP (Virtual Stack Pointer): Analog dengan RSP pada x86-64, menunjuk ke puncak stack virtual.
		      \item VREGS: Penunjuk ke awal area di stack yang menyimpan nilai register x86-64 yang disimpan.
		      \item VCS (Virtual Call Stack): Digunakan untuk menyimpan alamat kembali (return address) saat panggilan fungsi virtual.
		      \item VTEMP dan VTEMP2: Register sementara untuk perhitungan.
		      \item VCSRET: Menyimpan RVA yang digunakan dalam perhitungan VIP. Pemetaan register virtual ke register x86-64 dilakukan secara acak untuk mempersulit analisis.
	      \end{itemize}
	\item \bo{Virtual Call Stack (VCS):} EagleVM menggunakan virtual call stack untuk mendukung panggilan fungsi di dalam kode yang divirtualisasi. VCS menyimpan alamat kembali ke instruksi setelah panggilan fungsi, memungkinkan mesin virtual untuk melanjutkan eksekusi dengan benar setelah fungsi selesai.
	\item \bo{Handler Instruksi:} Setiap instruksi virtual memiliki handler yang berisi kode x86-64 untuk mengeksekusi instruksi tersebut. Handler inilah yang sebenarnya melakukan operasi yang ditentukan oleh instruksi virtual. EagleVM menyediakan handler untuk berbagai instruksi x86-64, dan pengembang dapat menambahkan handler baru untuk mendukung instruksi lain atau mengimplementasikan perilaku khusus.
	\item \bo{VMENTER dan VMEXIT:} VMENTER bertanggung jawab untuk memasuki lingkungan mesin virtual, menyimpan konteks x86-64, menginisialisasi konteks VM, dan memulai eksekusi bytecode. VMEXIT bertanggung jawab untuk keluar dari lingkungan mesin virtual, memulihkan konteks x86-64, dan mengembalikan kontrol ke kode asli.
\end{itemize}

\subsubsection{Alur Kerja Virtualisasi dengan EagleVM}
Proses virtualisasi kode dengan EagleVM melibatkan langkah-langkah berikut:
\begin{enumerate}
	\item \bo{Penandaan Kode Target:} Pengembang memasukkan panggilan ke fungsi fnEagleVMBegin dan fnEagleVMEnd dari EagleVM.Stub di dalam kode sumber mereka untuk menandai blok kode yang akan divirtualisasi.
	\item \bo{Kompilasi dan Linking:} Kode sumber dikompilasi dan di-link untuk menghasilkan file executable.
	\item \bo{Pemrosesan oleh EagleVM:} File executable yang dihasilkan kemudian diproses oleh EagleVM. EagleVM akan memparsing file executable, mencari panggilan ke fungsi penanda dari EagleVM.Stub, dan mengekstrak kode yang ditandai untuk divirtualisasi.
	\item \bo{Disassembly dan Analisis Alur Kontrol:} EagleVM melakukan disassembly pada kode yang akan divirtualisasi dan membangun representasi alur kontrol program dalam bentuk basic blocks. Analisis ini penting untuk memastikan bahwa alur eksekusi kode yang divirtualisasi tetap sama dengan kode aslinya.
	\item \bo{Transformasi ke Bytecode dan Pembuatan VM:} EagleVM menerjemahkan instruksi x86-64 asli ke dalam bytecode khusus untuk mesin virtualnya. EagleVM juga menghasilkan kode untuk mesin virtual yang akan mengeksekusi bytecode tersebut.
	\item \bo{Pembuatan Biner Output:} EagleVM menghasilkan biner output yang telah dimodifikasi, mengandung bytecode dan mesin virtual.
	\item \bo{Eksekusi:} Saat program dijalankan, mesin virtual yang tertanam dalam biner akan mengambil dan mengeksekusi bytecode, mereplikasi fungsionalitas dari kode asli.
\end{enumerate}
