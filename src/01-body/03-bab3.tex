%-----------------------------------------------------------------------------%
\chapter{\babTiga}
%-----------------------------------------------------------------------------%

%-----------------------------------------------------------------------------%
\section{Desain Penelitian}
%-----------------------------------------------------------------------------%
Penelitian ini menggunakan pendekatan eksperimental untuk menganalisis efektivitas code virtualization menggunakan VxLang dalam meningkatkan keamanan perangkat lunak dengan mempersulit reverse engineering. Fokus utama dari eksperimen ini adalah pada pengujian fungsionalitas autentikasi dan analisis performance overhead yang disebabkan oleh penerapan VxLang pada berbagai jenis aplikasi. Dua percobaan utama akan dilakukan:

\begin{enumerate}
	\item \bo{Pengujian Autentikasi - Analisis Statis dan Dinamis:} Percobaan ini bertujuan untuk menganalisis kompleksitas control flow program sebelum dan sesudah di-obfuscate menggunakan VxLang pada tiga jenis aplikasi yang berbeda:
	      \begin{itemize}
		      \item \bo{Aplikasi Konsol (Tanpa GUI) :} Aplikasi sederhana yang berinteraksi melalui command line.
		      \item \bo{Aplikasi Qt :} Aplikasi dengan antarmuka pengguna grafis yang dibangun menggunakan Qt Framework.
		      \item \bo{Aplikasi ImGUI :} Aplikasi dengan antarmuka pengguna grafis yang menggunakan library Dear ImGUI.
	      \end{itemize}
	      Analisis akan dilakukan melalui dua pendekatan: analisis statis menggunakan Ghidra dan analisis dinamis menggunakan x64Dbg. Selain itu, percobaan ini juga akan mencakup upaya untuk melewati pengujian autentikasi dengan memanipulasi control flow menggunakan Ghidra dan x64dbg pada ketiga jenis aplikasi tersebut. Tujuan dari pengujian pada berbagai aplikasi ini adalah untuk menunjukkan bahwa VxLang dapat diterapkan pada berbagai framework dan jenis kode sumber yang berbeda.
	\item \bo{Pengujian Performa - Waktu Eksekusi dan Ukuran File:} Percobaan ini bertujuan untuk mengukur performa waktu eksekusi program dengan algoritma sorting sebelum dan sesudah di-obfuscate, serta membandingkan ukuran file executable. Waktu eksekusi diukur menggunakan libraryÂ chrono::high\_resolution\_clock.
\end{enumerate}
%-----------------------------------------------------------------------------%
\section{Alat dan Bahan}
%-----------------------------------------------------------------------------%
Perangkat lunak dan perangkat keras yang digunakan dalam penelitian ini adalah:

\begin{itemize}
	\item \bo{Perangkat Lunak:}
	      \begin{itemize}
		      \item \bo{Sistem Operasi:} Windows 11 akan digunakan sebagai lingkungan operasi utama untuk melakukan semua percobaan.
		      \item \bo{Kompiler:} Kompiler Clang (clang-cl) akan digunakan untuk mengkompilasi kode sumber
		      \item \bo{Framwork GUI:} Qt Framework dan Dear ImGUI
		      \item \bo{Alat Virtualisasi Kode:} VxLang akan digunakan sebagai alat utama untuk mengimplementasikan virtualisasi kode.
		      \item \bo{Alat Analisis Statis:} Ghidra, sebuah framework reverse engineering yang dikembangkan oleh NSA, akan digunakan untuk melakukan analisis statis.
		      \item \bo{Alat Analisis Dinamis:} x64dbg, sebuah debugger sumber terbuka untuk Windows, akan digunakan untuk analisis dinamis
		      \item \bo{Pustaka C++:} Pustaka chrono akan digunakan untuk mengukur waktu eksekusi dan OpenSSL untuk melakukan enkripsi AES.
	      \end{itemize}
	\item \bo{Perangkat Lunak:}
	      \begin{itemize}
		      \item \bo{Prosesor:} Intel Core i7-12700H
		      \item \bo{RAM:} 32 GB
	      \end{itemize}
\end{itemize}

%-----------------------------------------------------------------------------%
\section{Prosedur Penelitian}
%-----------------------------------------------------------------------------%
\subsection{Pengujian Autentikasi: Analisis Statis dan Dinamis}
Pengujian autentikasi bertujuan untuk mengevaluasi efektivitas virtualisasi kode dalam menghambat upaya reverse engineering dengan menganalisis aspek statis dan dinamis dari perangkat lunak sebelum dan sesudah obfuscation, serta mencoba untuk melewati mekanisme autentikasi.

Berikut persiapan yang akan dilakukan :
\begin{enumerate}
	\item \bo{Pengaturan Lingkungan:} Lingkungan perangkat lunak diatur untuk memastikan bahwa semua alat (Windows 11, Clang, VxLang, Ghidra, dan x64dbg) serta framework dan library GUI (Qt dan Dear ImGUI) terinstal dan terkonfigurasi dengan benar. Kode sumber aplikasi studi kasus (konsol, Qt, dan Dear ImGUI) disiapkan untuk kompilasi.
	\item \bo{Kompilasi Aplikasi Asli:} Setiap aplikasi studi kasus (konsol, Qt, dan Dear ImGUI) dikompilasi tanpa menerapkan teknik obfuscation apa pun menggunakan kompiler Clang. Hasilnya adalah file executable asli untuk setiap jenis aplikasi.
	\item \bo{Kompilasi Aplikasi yang di-Obfuscate:} Kode sumber aplikasi studi kasus dimodifikasi untuk menyertakan penanda VL\_VIRTUALIZATION\_BEGIN dan VL\_VIRTUALIZATION\_END untuk menunjukkan blok kode yang akan divirtualisasikan. Kode sumber yang dimodifikasi dikompilasi dengan kompiler Clang, dan selanjutnya, executable diproses dengan VxLang untuk menghasilkan versi yang di-obfuscate yang menyertakan mesin virtual dan bytecode yang sesuai.
\end{enumerate}

\begin{figure}
	\centering
	\includegraphics[width=1\textwidth]
	{assets/pics/Persiapan.png}
	\caption{Flow Diagram Persiapan Penelitian}
\end{figure}

\subsubsection{Analisis Statis (Ghidra)}
Fase ini bertujuan untuk menganalisis struktur dan kompleksitas kode tanpa menjalankannya.
\begin{enumerate}
	\item \bo{Peluncuran Ghidra:} Framework Ghidra diluncurkan, dan proyek baru dibuat untuk menampung analisis setiap versi aplikasi (asli dan di-obfuscate untuk konsol, Qt, dan Dear ImGUI).
	\item \bo{Mengimpor Executable:} Baik file executable asli maupun yang di-obfuscate diimpor ke dalam proyek Ghidra.
	\item \bo{Analisis Fungsi:} Fungsi yang menangani proses autentikasi dalam setiap aplikasi dipilih untuk analisis terfokus. Alat analisis Ghidra digunakan untuk membongkar fungsi target dan menghasilkan Control Flow Graph (CFG) untuk kedua versi (obfuscated dan non-obfuscated) dari setiap jenis aplikasi.
	\item \bo{Perbandingan CFG:} CFG dari versi asli dan yang di-obfuscate dibandingkan dengan mendokumentasikan jumlah basic block, edge, dan kompleksitas siklomatik. Kompleksitas siklomatik yang lebih tinggi berkorelasi dengan peningkatan kesulitan dalam pemahaman kode dan reverse engineering. Dokumentasi untuk setiap versi akan mencakup yang berikut:
	      \begin{itemize}
		      \item \bo{Jumlah Basic Block:} Ini menunjukkan jumlah total urutan kode non-percabangan dalam alur kontrol fungsi.
		      \item \bo{Jumlah Edge:} Ini mewakili alur eksekusi dari satu blok ke blok lainnya.
		      \item \bo{Kompleksitas Siklomatik:} Metrik ini mengukur jumlah jalur independen dalam alur kontrol kode. Ini dihitung berdasarkan rumus: Edge - Node + 2
	      \end{itemize}
	\item \bo{Mendokumentasikan Temuan:} Catatan dan observasi terperinci mengenai analisis statis kode dipelihara.
\end{enumerate}

\begin{figure}
	\centering
	\includegraphics[width=1\textwidth]
	{assets/pics/Static.png}
	\caption{Flow Diagram Analisis Statis}
\end{figure}

\bo{Upaya Manipulasi Control Flow:}
\begin{enumerate}
	\item \bo{Identifikasi Mekanisme Autentikasi:} Menggunakan Ghidra, identifikasi bagian kode yang menangani proses autentikasi. Ini melibatkan pencarian fungsi yang memvalidasi kredensial atau memeriksa lisensi.
	\item \bo{Analisis Control Flow:} Analisis control flow dari fungsi autentikasi untuk memahami bagaimana keputusan autentikasi dibuat.
	\item \bo{Identifikasi Peluang Manipulasi:} Cari peluang untuk memodifikasi control flow (misalnya, mengubah jump kondisional) yang dapat menyebabkan aplikasi selalu menganggap autentikasi berhasil.
	\item \bi{Patching Executable:} Jika memungkinkan, coba patch executable asli menggunakan Ghidra untuk melewati mekanisme autentikasi pada setiap jenis aplikasi.
	\item \bo{Uji Coba Aplikasi yang di-Patch:} Jalankan aplikasi yang di-patch untuk memverifikasi apakah upaya melewati autentikasi berhasil.
	\item \bo{Ulangi pada Aplikasi yang di-Obfuscate:} Lakukan langkah yang sama pada versi aplikasi yang di-obfuscate untuk melihat apakah virtualisasi kode mempersulit upaya manipulasi control flow untuk melewati autentikasi pada setiap jenis aplikasi.
\end{enumerate}

\subsubsection{Analisis Dinamis (x64dbg)}
Analisis dinamis melibatkan pengamatan perilaku program saat dijalankan.
\begin{enumerate}
	\item \bo{Peluncuran x64Dbg:} Debugger x64dbg diluncurkan, dan executable asli dan yang di-obfuscate (untuk konsol, Qt, dan Dear ImGUI) dimuat untuk analisis.
	\item \bo{Pengamatan Alur Eksekusi Autentikasi:} Breakpoint diatur pada fungsi autentikasi untuk mengamati alur eksekusi dan nilai variabel yang relevan selama proses autentikasi pada setiap jenis aplikasi.
	\item \bo{Analisis Perbedaan Alur Kontrol:} Bandingkan alur kontrol eksekusi fungsi autentikasi antara versi asli dan yang di-obfuscate untuk setiap jenis aplikasi. Perhatikan bagaimana virtualisasi kode mengubah urutan instruksi dan mempersulit pemahaman alur kontrol yang sebenarnya.
	\item \bo{Upaya Melewati Autentikasi:} Gunakan x64dbg untuk mencoba memanipulasi alur eksekusi atau nilai variabel selama runtime dengan tujuan untuk melewati mekanisme autentikasi pada setiap jenis aplikasi. Misalnya, coba ubah hasil perbandingan password agar selalu bernilai benar.
	\item \bo{Dokumentasi Temuan:} Catat semua observasi, termasuk kesulitan dalam memahami alur kontrol dan keberhasilan atau kegagalan upaya melewati autentikasi pada setiap jenis aplikasi.
\end{enumerate}

\begin{figure}
	\centering
	\includegraphics[width=1\textwidth]
	{assets/pics/Dynamic.png}
	\caption{Flow Diagram Analisis Dinamis}
\end{figure}

\subsection{Pengujian Performa: Waktu Eksekusi dan Ukuran File}
Pengujian kinerja ini bertujuan untuk mengevaluasi dampak virtualisasi kode terhadap waktu eksekusi dan ukuran file aplikasi. Untuk mendapatkan pengukuran yang komprehensif, kita akan menggunakan algoritma pengurutan (sorting) sebagai benchmark.

Berikut persiapan yang akan dilakukan :
\begin{enumerate}
	\item \bo{Pemilihan Algoritma Pengurutan:} Algoritma pengurutan yang akan digunakan sebagai benchmark adalah algoritma pengurutan cepat (Quicksort). Quicksort dipilih karena efisiensinya yang baik dalam banyak kasus, serta kompleksitasnya yang cukup untuk memberikan gambaran yang baik tentang performa.
	\item \bo{Pengembangan Benchmark:} Benchmark akan diimplementasikan dengan membuat fungsi yang melakukan pengurutan pada array data. Array data akan diisi dengan angka acak untuk memastikan pengujian yang representatif. Ukuran array data akan divariasikan (misalnya, 1000, 10000, 100000 elemen) untuk mengamati performa pada berbagai skala data.
	\item \bo{Integrasi Benchmark:} Fungsi benchmark diintegrasikan ke dalam kedua versi aplikasi (asli dan yang di-obfuscate). Hal ini memungkinkan kita untuk mengukur waktu eksekusi dari algoritma pengurutan pada kedua versi aplikasi secara terpisah.
\end{enumerate}

\subsubsection{Pengukuran Waktu Eksekusi Enskripsi AES}
\begin{enumerate}
	\item \bo{Benchmark:} Fungsi benchmark akan melakukan enkripsi AES-CBC-256 pada 1 Gigabyte blok.
	\item \bo{Pengukuran Waktu:} Pustaka chrono::high\_resolution\_clock dari C++ akan digunakan untuk mengukur secara akurat waktu yang dibutuhkan untuk setiap eksekusi benchmark.
	\item \bo{Pencatatan Data:} Waktu eksekusi setiap run (dalam milidetik atau mikrosekon) dicatat untuk setiap ukuran array pada kedua versi aplikasi.
\end{enumerate}

\subsubsection{Pengukuran Waktu Eksekusi Quick Sort}
\begin{enumerate}
	\item \bo{Eksekusi Benchmark:} Fungsi benchmark (algoritma pengurutan) akan dieksekusi beberapa kali (misalnya, N=100) pada setiap ukuran array untuk mendapatkan data yang cukup.
	\item \bo{Pengukuran Waktu:} Pustaka chrono::high\_resolution\_clock dari C++ akan digunakan untuk mengukur secara akurat waktu yang dibutuhkan untuk setiap eksekusi benchmark.
	\item \bo{Pencatatan Data:} Waktu eksekusi setiap run (dalam milidetik atau mikrosekon) dicatat untuk setiap ukuran array pada kedua versi aplikasi.
	\item \bo{Perhitungan Rata-Rata:} Waktu eksekusi rata-rata dihitung untuk setiap versi dan setiap ukuran array dengan menjumlahkan semua waktu eksekusi dan membaginya dengan jumlah run (N).
\end{enumerate}

\subsubsection{Pengukuran Ukuran File}
\begin{enumerate}
	\item \bo{Perbandingan Ukuran File:} Ukuran file dari executable asli dan yang di-obfuscate dibandingkan untuk menentukan dampak virtualisasi kode pada ukuran aplikasi.
\end{enumerate}

\begin{figure}
	\centering
	\includegraphics[width=1\textwidth]
	{assets/pics/Performance.png}
	\caption{Flow Diagram Analisis Performa}
\end{figure}

\section{Teknik Analisis Data}
Data yang dikumpulkan dari kedua rangkaian percobaan akan dianalisis menggunakan teknik deskriptif dan komparatif.
\subsection{Analisis Data Pengujian Autentikasi}
\begin{itemize}
	\item \bo{Analisis Data Statis:} Metrik kompleksitas yang diperoleh dari analisis statis (yaitu, jumlah basic block, edge, dan kompleksitas siklomatik) akan dievaluasi. Perbedaan akan digunakan untuk menilai efektivitas virtualisasi kode.
	\item \bo{Analisis Data Dinamis:} Hasil dari analisis dinamis, termasuk alur eksekusi yang diamati dan kesulitan dalam analisis kode, akan dianalisis.
	\item \bo{Evaluasi Efektivitas Keamanan:} Hasil dari analisis dinamis, termasuk alur eksekusi yang diamati dan kesulitan dalam analisis kode, akan dianalisis.
\end{itemize}

\subsection{Analisis Data Pengujian Performa}
\begin{itemize}
	\item \bo{Perbandingan Waktu Eksekusi:} Waktu eksekusi rata-rata antara aplikasi asli dan yang di-obfuscate dibandingkan untuk menilai potensi overhead kinerja yang diperkenalkan oleh VxLang.
	\item \bo{Perbandingan Ukuran File:} Ukuran file dari kedua versi dibandingkan untuk menilai dampak ukuran file dari virtualisasi kode.
	\item \bo{Analisis Trade-off:} Analisis komprehensif dilakukan untuk mengevaluasi trade-off antara keamanan dan kinerja, berdasarkan temuan.
\end{itemize}
