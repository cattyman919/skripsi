\section{Implementation Details} \label{sec:implementation}
This section briefly outlines the key aspects of the experimental setup and the integration of VxLang.

\subsection{Development Environment}
All development and testing were conducted on a Windows 11 (64-bit) system. The Clang compiler (v19.1.3, via \texttt{clang-cl} for MSVC ABI compatibility) targeting x86-64 was used with the C++17 standard. CMake (v3.31) and Ninja (v1.12.1) managed the build process. Essential libraries included the VxLang SDK, Qt 6, Dear ImGui, OpenSSL 3.x, and libcurl, linked appropriately via CMake.

\subsection{VxLang Integration}
VxLang was applied to the target applications using its Software Development Kit (SDK) and external processing tool.

\subsubsection{Code Marking} Critical code sections intended for virtualization were demarcated in the C++ source code using the SDK's macros, primarily \texttt{VL\_VIRTUALIZATION\_BEGIN} and \texttt{VL\_VIRTUALIZATION\_END}. For instance, in the authentication logic:

\begin{minted}[fontsize=\small, breaklines, escapeinside=||]{cpp}
// ... Input username/password ...
#ifdef USE_VL_MACRO
VL_VIRTUALIZATION_BEGIN; // Mark start
#endif

if (check_credentials(username, password)) {
    // Authorized path
} else {
    // Unauthorized path
}

#ifdef USE_VL_MACRO
VL_VIRTUALIZATION_END; // Mark end
#endif
// ...
\end{minted}
Similar macros were placed around the recursive \texttt{quickSort} function body and the main encryption/decryption loop in the AES benchmark.

\subsubsection{Build Process} The CMake configuration was set up to generate two distinct build types:
\begin{enumerate}
    \item \textbf{Original Build:} Compiled without the \texttt{USE\_VL\_MACRO} preprocessor definition and without linking the VxLang library. Produces the baseline executable (e.g., \texttt{app\_qt.exe}).
    \item \textbf{Intermediate Build (VM Marked):} Compiled with \texttt{USE\_VL\_MACRO} defined and linked against \texttt{vxlib64.lib}. Produces an intermediate executable containing the VxLang markers (e.g., \texttt{app\_qt\_vm.exe}).
\end{enumerate}

\subsubsection{Virtualization Processing}
The intermediate executables (e.g., \texttt{app\_qt\_vm.exe}) generated by the build process, which contain the VxLang markers and are linked against the VxLang library, were then directly processed using the VxLang command-line tool. This was done by executing the tool with the intermediate executable as an argument, for example:

\begin{minted}[fontsize=\small, breaklines, escapeinside=||, frame=none]{bash}
vxlang.exe app_qt_vm.exe
\end{minted}

This command automatically processes the input file, replacing the native code within the marked sections (\texttt{VL\_VIRTUALIZATION\_BEGIN/END}) with its corresponding virtualized bytecode and embedding the necessary VM runtime. The tool generates the final virtualized executable in the same directory, automatically appending \texttt{\_vxm} to the original filename (e.g., producing \texttt{app\_qt\_vxm.exe}). This resulting \texttt{*\_vxm.exe} file was then used for all subsequent testing and analysis. No explicit configuration files (like JSON) were used in this processing step.

\subsection{Lilith RAT Preparation}
The Lilith RAT client source code \cite{LilithRAT} was compiled using the same environment (Clang/clang-cl, CMake, Ninja). For the virtualized version, VxLang SDK macros (\texttt{VL\_VIRTUALIZATION\_BEGIN/END}) were strategically placed around key functional blocks within the client's source code, targeting areas responsible for connection handling, command processing, and core RAT functionalities. An intermediate executable (\texttt{Lilith\_Client\_vm.exe}) was built with the \texttt{USE\_VL\_MACRO} flag and linked against \texttt{vxlib64.lib}. This intermediate file was then directly processed using the external VxLang command-line tool (\texttt{vxlang.exe Lilith\_Client\_vm.exe}) to produce the final virtualized Lilith client executable (\texttt{Lilith\_Client\_vxm.exe}) used in the analysis. The Lilith server component remained unmodified.

It is pertinent to note that the strategic placement of VxLang macros was crucial for maintaining the functional integrity of the Lilith RAT client. Initial attempts to virtualize larger, more complex code blocks, particularly those involving intricate control flow (e.g., entire switch-case statements handling packet types) or direct network I/O calls, occasionally resulted in application instability or crashes. Stable functionality was achieved by applying virtualization more granularly to specific, well-contained functions or critical logical segments, underscoring the need for careful, iterative testing when integrating VM-based obfuscation into complex applications.
